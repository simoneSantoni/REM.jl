var documenterSearchIndex = {"docs":
[{"location":"guide/estimation/#Model-Estimation","page":"Model Estimation","title":"Model Estimation","text":"REM.jl estimates relational event models using case-control sampling with stratified conditional logistic regression (equivalent to Cox proportional hazards for survival data).","category":"section"},{"location":"guide/estimation/#Case-Control-Sampling","page":"Model Estimation","title":"Case-Control Sampling","text":"For large networks, computing statistics for all possible dyads is computationally expensive. Case-control sampling provides an efficient alternative:\n\nFor each observed event (case), sample a set of non-events (controls)\nCompute statistics for both cases and controls\nEstimate the model using stratified conditional logistic regression\n\n# Configure sampling\nsampler = CaseControlSampler(\n    n_controls = 100,        # Controls per case\n    exclude_self_loops = true,\n    seed = 42                # For reproducibility\n)","category":"section"},{"location":"guide/estimation/#Generating-Observations","page":"Model Estimation","title":"Generating Observations","text":"# Generate case-control observations\nobs = generate_observations(seq, stats, sampler)\n\nThe resulting DataFrame contains:\n\nevent_index - Index of the focal event\nsender, receiver - Dyad IDs\nis_event - True for cases, false for controls\nstratum - Stratum ID (groups cases with their controls)\nColumns for each statistic","category":"section"},{"location":"guide/estimation/#Options","page":"Model Estimation","title":"Options","text":"generate_observations(seq, stats, sampler;\n    start_index = 1,           # First event to include\n    end_index = length(seq),   # Last event to include\n    decay = 0.0,               # Exponential decay rate\n    at_risk = nothing          # Custom set of actors at risk\n)","category":"section"},{"location":"guide/estimation/#Fitting-Models","page":"Model Estimation","title":"Fitting Models","text":"","category":"section"},{"location":"guide/estimation/#Direct-Fitting","page":"Model Estimation","title":"Direct Fitting","text":"The simplest approach:\n\nresult = fit_rem(seq, stats;\n    n_controls = 100,\n    seed = 42\n)","category":"section"},{"location":"guide/estimation/#Two-Stage-Fitting","page":"Model Estimation","title":"Two-Stage Fitting","text":"For more control:\n\n# Stage 1: Generate observations\nsampler = CaseControlSampler(n_controls=100, seed=42)\nobs = generate_observations(seq, stats, sampler)\n\n# Stage 2: Fit model\nstat_names = [name(s) for s in stats]\nresult = fit_rem(obs, stat_names)","category":"section"},{"location":"guide/estimation/#Fit-Options","page":"Model Estimation","title":"Fit Options","text":"fit_rem(obs, stat_names;\n    maxiter = 100,   # Maximum Newton-Raphson iterations\n    tol = 1e-8       # Convergence tolerance\n)","category":"section"},{"location":"guide/estimation/#Results","page":"Model Estimation","title":"Results","text":"The REMResult object contains:\n\nresult.coefficients    # Estimated coefficients\nresult.std_errors      # Standard errors\nresult.z_values        # Z-statistics\nresult.p_values        # Two-sided p-values\nresult.stat_names      # Statistic names\nresult.n_events        # Number of events\nresult.n_observations  # Total observations\nresult.log_likelihood  # Log-likelihood at convergence\nresult.converged       # Convergence indicator","category":"section"},{"location":"guide/estimation/#Accessor-Functions","page":"Model Estimation","title":"Accessor Functions","text":"coef(result)        # Coefficients vector\nstderror(result)    # Standard errors vector\ncoeftable(result)   # Full table as DataFrame","category":"section"},{"location":"guide/estimation/#Displaying-Results","page":"Model Estimation","title":"Displaying Results","text":"println(result)\n\nOutput:\n\nRelational Event Model Results\n==============================\nEvents: 100, Observations: 10100\nLog-likelihood: -234.5678\nConverged: true\n\nCoefficients:\n------------------------------------------------------------\nStatistic                  Coef    Std.Err          z      P>|z|\n------------------------------------------------------------\nrepetition               0.4523     0.0812     5.5700     0.0000 ***\nreciprocity              0.3156     0.0923     3.4200     0.0006 ***\nsender_activity          0.0234     0.0156     1.5000     0.1336\nreceiver_popularity      0.0567     0.0189     3.0000     0.0027 **\n------------------------------------------------------------\nSignif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1","category":"section"},{"location":"guide/estimation/#Interpreting-Coefficients","page":"Model Estimation","title":"Interpreting Coefficients","text":"","category":"section"},{"location":"guide/estimation/#Log-Hazard-Ratios","page":"Model Estimation","title":"Log-Hazard Ratios","text":"Coefficients are log-hazard ratios. A coefficient β means:\n\nexp(β) is the multiplicative effect on the event rate\nβ > 0 increases the rate\nβ < 0 decreases the rate","category":"section"},{"location":"guide/estimation/#Example-Interpretations","page":"Model Estimation","title":"Example Interpretations","text":"Statistic Coefficient Interpretation\nRepetition 0.5 Each past s→r event increases rate by 65% (exp(0.5) ≈ 1.65)\nReciprocity 0.8 Past r→s events increase rate by 123% (exp(0.8) ≈ 2.23)\nSenderActivity -0.1 High-activity senders have slightly lower per-dyad rates\nTransitiveClosure 0.3 Each shared partner increases rate by 35%","category":"section"},{"location":"guide/estimation/#Computing-Statistics-Without-Sampling","page":"Model Estimation","title":"Computing Statistics Without Sampling","text":"To compute statistics for actual events only (no controls):\n\nstats_df = compute_statistics(seq, stats; decay=0.0)\n\nThis returns a DataFrame with one row per event and columns for:\n\nsender, receiver, time\nEach statistic value","category":"section"},{"location":"guide/estimation/#Model-Selection","page":"Model Estimation","title":"Model Selection","text":"","category":"section"},{"location":"guide/estimation/#Comparing-Models","page":"Model Estimation","title":"Comparing Models","text":"# Fit multiple models\nstats1 = [Repetition(), Reciprocity()]\nstats2 = [Repetition(), Reciprocity(), TransitiveClosure()]\n\nresult1 = fit_rem(seq, stats1; n_controls=100, seed=42)\nresult2 = fit_rem(seq, stats2; n_controls=100, seed=42)\n\n# Compare log-likelihoods\nprintln(\"Model 1 LL: \", result1.log_likelihood)\nprintln(\"Model 2 LL: \", result2.log_likelihood)","category":"section"},{"location":"guide/estimation/#Checking-Convergence","page":"Model Estimation","title":"Checking Convergence","text":"if !result.converged\n    @warn \"Model did not converge\"\nend","category":"section"},{"location":"guide/estimation/#Best-Practices","page":"Model Estimation","title":"Best Practices","text":"Number of controls: More controls = more accurate estimates but slower computation. 50-200 is typically sufficient.\nRandom seed: Always set a seed for reproducibility.\nCheck convergence: Verify result.converged == true.\nAvoid multicollinearity: Don't include highly correlated statistics.\nScale statistics: For very large networks, consider log-transforming degree statistics.\nSufficient events: Need enough events for stable estimation. Rule of thumb: at least 10 events per parameter.","category":"section"},{"location":"api/types/#Types-API-Reference","page":"Types","title":"Types API Reference","text":"","category":"section"},{"location":"api/types/#Events","page":"Types","title":"Events","text":"","category":"section"},{"location":"api/types/#Actor-Data","page":"Types","title":"Actor Data","text":"","category":"section"},{"location":"api/types/#Network-State","page":"Types","title":"Network State","text":"","category":"section"},{"location":"api/types/#State-Query-Functions","page":"Types","title":"State Query Functions","text":"","category":"section"},{"location":"api/types/#REM.Event","page":"Types","title":"REM.Event","text":"Event{T}\n\nRepresents a single relational event (directed interaction between actors).\n\nFields\n\nsender::Int: ID of the event sender/source\nreceiver::Int: ID of the event receiver/target\ntime::T: Timestamp of the event\neventtype::Symbol: Type/category of the event (default: :event)\nweight::Float64: Weight/magnitude of the event (default: 1.0)\n\n\n\n\n\n","category":"type"},{"location":"api/types/#REM.EventSequence","page":"Types","title":"REM.EventSequence","text":"EventSequence{T}\n\nA sequence of relational events, sorted by time.\n\nFields\n\nevents::Vector{Event{T}}: Vector of events sorted by time\nactors::Set{Int}: Set of all actor IDs\nn_actors::Int: Number of unique actors\neventtypes::Set{Symbol}: Set of all event types\n\n\n\n\n\n","category":"type"},{"location":"api/types/#REM.ActorSet","page":"Types","title":"REM.ActorSet","text":"ActorSet\n\nRepresents a set of actors with optional ID-to-name mapping.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#REM.NodeAttribute","page":"Types","title":"REM.NodeAttribute","text":"NodeAttribute{T}\n\nStores an attribute value for each actor.\n\nFields\n\nname::Symbol: Name of the attribute\nvalues::Dict{Int, T}: Mapping from actor ID to attribute value\ndefault::T: Default value for actors not in the dict\n\n\n\n\n\n","category":"type"},{"location":"api/types/#REM.RiskSet","page":"Types","title":"REM.RiskSet","text":"RiskSet\n\nRepresents the risk set for a given event - the set of potential dyads that could have experienced an event at a given time.\n\nFields\n\nevent_index::Int: Index of the focal event in the sequence\npotential_senders::Vector{Int}: Actors who could be senders\npotential_receivers::Vector{Int}: Actors who could be receivers\nexclude_self_loops::Bool: Whether to exclude self-loops from risk set\n\n\n\n\n\n","category":"type"},{"location":"api/types/#REM.NetworkState","page":"Types","title":"REM.NetworkState","text":"NetworkState\n\nTracks the cumulative state of the network up to a given point in time. Used for efficient computation of statistics.\n\nFields\n\nn_actors::Int: Number of actors\ndyad_counts::Dict{Tuple{Int,Int}, Float64}: Weighted count of events for each directed dyad\nundirected_counts::Dict{Tuple{Int,Int}, Float64}: Weighted count for undirected dyads (min,max sorted)\nout_degree::Dict{Int, Float64}: Weighted out-degree for each actor\nin_degree::Dict{Int, Float64}: Weighted in-degree for each actor\nlast_event_time::Dict{Tuple{Int,Int}, Any}: Time of last event for each dyad\ndecay::Float64: Exponential decay rate (0 = no decay)\ncurrent_time::Any: Current time in the event sequence\n\n\n\n\n\n","category":"type"},{"location":"api/types/#REM.update!","page":"Types","title":"REM.update!","text":"update!(state::NetworkState, event::Event)\n\nUpdate the network state with a new event.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#REM.reset!","page":"Types","title":"REM.reset!","text":"reset!(state::NetworkState)\n\nReset the network state to empty.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#REM.get_dyad_count","page":"Types","title":"REM.get_dyad_count","text":"get_dyad_count(state::NetworkState, sender::Int, receiver::Int) -> Float64\n\nGet the weighted count of events from sender to receiver.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#REM.get_undirected_count","page":"Types","title":"REM.get_undirected_count","text":"get_undirected_count(state::NetworkState, actor1::Int, actor2::Int) -> Float64\n\nGet the weighted count of events between two actors (in either direction).\n\n\n\n\n\n","category":"function"},{"location":"api/types/#REM.get_out_degree","page":"Types","title":"REM.get_out_degree","text":"get_out_degree(state::NetworkState, actor::Int) -> Float64\n\nGet the weighted out-degree of an actor.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#REM.get_in_degree","page":"Types","title":"REM.get_in_degree","text":"get_in_degree(state::NetworkState, actor::Int) -> Float64\n\nGet the weighted in-degree of an actor.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#REM.get_out_neighbors","page":"Types","title":"REM.get_out_neighbors","text":"get_out_neighbors(state::NetworkState, actor::Int) -> Set{Int}\n\nGet the set of actors to whom the given actor has sent events.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#REM.get_in_neighbors","page":"Types","title":"REM.get_in_neighbors","text":"get_in_neighbors(state::NetworkState, actor::Int) -> Set{Int}\n\nGet the set of actors who have sent events to the given actor.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#REM.has_edge","page":"Types","title":"REM.has_edge","text":"has_edge(state::NetworkState, sender::Int, receiver::Int) -> Bool\n\nCheck if there has been at least one event from sender to receiver.\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This guide will help you get started with REM.jl for analyzing relational event data.","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"Install REM.jl from GitHub:\n\nusing Pkg\nPkg.add(url=\"https://github.com/simoneSantoni/REM.jl\")","category":"section"},{"location":"getting_started/#Basic-Workflow","page":"Getting Started","title":"Basic Workflow","text":"The typical REM.jl workflow consists of four steps:\n\nLoad or create events - Prepare your relational event data\nDefine statistics - Choose which effects to model\nFit the model - Estimate coefficients\nInterpret results - Analyze the fitted model","category":"section"},{"location":"getting_started/#Step-1:-Create-an-Event-Sequence","page":"Getting Started","title":"Step 1: Create an Event Sequence","text":"Events represent directed interactions between actors at specific times:\n\nusing REM\n\n# Create individual events: Event(sender, receiver, time)\nevents = [\n    Event(1, 2, 1.0),   # Actor 1 → Actor 2 at time 1.0\n    Event(2, 1, 2.0),   # Actor 2 → Actor 1 at time 2.0\n    Event(1, 3, 3.0),   # Actor 1 → Actor 3 at time 3.0\n    Event(3, 2, 4.0),   # Actor 3 → Actor 2 at time 4.0\n    Event(2, 3, 5.0),   # Actor 2 → Actor 3 at time 5.0\n    Event(1, 2, 6.0),   # Actor 1 → Actor 2 at time 6.0\n]\n\n# Create an EventSequence (automatically sorted by time)\nseq = EventSequence(events)\n\nprintln(\"Number of events: \", length(seq))\nprintln(\"Number of actors: \", seq.n_actors)","category":"section"},{"location":"getting_started/#Loading-from-a-DataFrame","page":"Getting Started","title":"Loading from a DataFrame","text":"More commonly, you'll load events from existing data:\n\nusing DataFrames\n\ndf = DataFrame(\n    sender = [1, 2, 1, 3, 2, 1],\n    receiver = [2, 1, 3, 2, 3, 2],\n    time = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n)\n\nseq = load_events(df)","category":"section"},{"location":"getting_started/#Loading-from-CSV","page":"Getting Started","title":"Loading from CSV","text":"seq = load_events(\"path/to/events.csv\")","category":"section"},{"location":"getting_started/#Step-2:-Define-Statistics","page":"Getting Started","title":"Step 2: Define Statistics","text":"Statistics capture different mechanisms that might drive event occurrence:\n\n# Basic dyadic statistics\nstats = [\n    Repetition(),           # Past events from sender to receiver\n    Reciprocity(),          # Past events from receiver to sender\n    SenderActivity(),       # Sender's overall activity (out-degree)\n    ReceiverPopularity(),   # Receiver's overall popularity (in-degree)\n]","category":"section"},{"location":"getting_started/#Exploring-Available-Statistics","page":"Getting Started","title":"Exploring Available Statistics","text":"REM.jl provides many statistics organized by type:\n\n# Dyad statistics - history between the focal dyad\nRepetition()              # s→r history\nReciprocity()             # r→s history\nInertiaStatistic()        # Combined repetition and reciprocity\nRecencyStatistic()        # Time since last s→r event\n\n# Degree statistics - actor activity/popularity\nSenderActivity()          # Sender's out-degree\nReceiverActivity()        # Receiver's out-degree\nSenderPopularity()        # Sender's in-degree\nReceiverPopularity()      # Receiver's in-degree\n\n# Triangle statistics - triadic closure\nTransitiveClosure()       # s→k→r patterns (friends of friends)\nCyclicClosure()           # r→k→s patterns\nSharedSender()            # k→s and k→r patterns\nSharedReceiver()          # s→k and r→k patterns","category":"section"},{"location":"getting_started/#Step-3:-Fit-the-Model","page":"Getting Started","title":"Step 3: Fit the Model","text":"Use fit_rem to estimate the model:\n\nresult = fit_rem(seq, stats; n_controls=100, seed=42)\n\nKey parameters:\n\nn_controls: Number of control samples per event (higher = more accurate, slower)\nseed: Random seed for reproducibility\ndecay: Exponential decay rate for temporal effects (default: 0.0 = no decay)","category":"section"},{"location":"getting_started/#Step-4:-Interpret-Results","page":"Getting Started","title":"Step 4: Interpret Results","text":"The result object contains coefficient estimates and test statistics:\n\n# Print summary table\nprintln(result)\n\n# Access specific values\ncoef(result)        # Vector of coefficients\nstderror(result)    # Standard errors\ncoeftable(result)   # Full table as DataFrame","category":"section"},{"location":"getting_started/#Interpreting-Coefficients","page":"Getting Started","title":"Interpreting Coefficients","text":"Positive coefficient: The statistic increases the rate of events\nNegative coefficient: The statistic decreases the rate of events\nCoefficients are log-hazard ratios: exp(coef) gives the multiplicative effect\n\nExample interpretation:\n\nrepetition = 0.5 means each past s→r event increases the rate by a factor of exp(0.5) ≈ 1.65\nreciprocity = 0.8 means events are exp(0.8) ≈ 2.2 times more likely when r→s has occurred","category":"section"},{"location":"getting_started/#Complete-Example","page":"Getting Started","title":"Complete Example","text":"using REM\nusing DataFrames\n\n# Simulate some event data\nevents = [\n    Event(1, 2, 1.0),\n    Event(2, 1, 2.0),\n    Event(1, 2, 3.0),  # Repetition of 1→2\n    Event(2, 3, 4.0),\n    Event(3, 1, 5.0),\n    Event(1, 3, 6.0),  # Reciprocity of 3→1\n]\nseq = EventSequence(events)\n\n# Define model\nstats = [\n    Repetition(),\n    Reciprocity(),\n    SenderActivity(),\n    ReceiverPopularity(),\n    TransitiveClosure(),\n]\n\n# Fit with case-control sampling\nresult = fit_rem(seq, stats; n_controls=50, seed=123)\n\n# View results\nprintln(result)\n\n# Get coefficient table\ndf = coeftable(result)\nprintln(df)","category":"section"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Learn about Events and Data for data handling\nExplore all Statistics available\nUnderstand Model Estimation in detail\nUse Temporal Decay for time-weighted effects","category":"section"},{"location":"api/estimation/#Estimation-API-Reference","page":"Estimation","title":"Estimation API Reference","text":"","category":"section"},{"location":"api/estimation/#Data-Loading","page":"Estimation","title":"Data Loading","text":"","category":"section"},{"location":"api/estimation/#Observation-Generation","page":"Estimation","title":"Observation Generation","text":"","category":"section"},{"location":"api/estimation/#Model-Fitting","page":"Estimation","title":"Model Fitting","text":"","category":"section"},{"location":"api/estimation/#Utility-Functions","page":"Estimation","title":"Utility Functions","text":"","category":"section"},{"location":"api/estimation/#REM.load_events","page":"Estimation","title":"REM.load_events","text":"load_events(filepath::String; kwargs...) -> EventSequence\n\nLoad events from a CSV file.\n\nArguments\n\nfilepath: Path to the CSV file\n\nKeyword Arguments\n\nsender_col::Symbol=:sender: Column name for sender IDs\nreceiver_col::Symbol=:receiver: Column name for receiver IDs\ntime_col::Symbol=:time: Column name for timestamps\ntype_col::Union{Symbol,Nothing}=nothing: Column name for event types\nweight_col::Union{Symbol,Nothing}=nothing: Column name for event weights\ntime_type::Type=Float64: Type to parse timestamps as\nactor_names::Bool=false: If true, treat sender/receiver as names and assign numeric IDs\n\nReturns\n\nEventSequence: Sequence of loaded events\n\n\n\n\n\nload_events(df::DataFrame; kwargs...) -> EventSequence\n\nLoad events from a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.load_events!","page":"Estimation","title":"REM.load_events!","text":"load_events!(seq::EventSequence, filepath::String; kwargs...)\n\nLoad events from a CSV file and add them to an existing EventSequence.\n\n\n\n\n\nload_events!(seq::EventSequence, df::DataFrame; kwargs...)\n\nLoad events from a DataFrame and add them to an existing EventSequence.\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.Observation","page":"Estimation","title":"REM.Observation","text":"Observation\n\nA single observation for model estimation, consisting of:\n\nStatistics computed for a potential event (sender→receiver)\nWhether the event actually occurred (case) or not (control)\n\nFields\n\nevent_index::Int: Index of the focal event in the sequence\nsender::Int: Sender ID\nreceiver::Int: Receiver ID\nstatistics::Vector{Float64}: Computed statistic values\nis_event::Bool: True if this dyad actually had an event (case)\nstratum::Int: Stratum ID for stratified analysis (events in same stratum share risk set)\n\n\n\n\n\n","category":"type"},{"location":"api/estimation/#REM.CaseControlSampler","page":"Estimation","title":"REM.CaseControlSampler","text":"CaseControlSampler\n\nGenerates observations using case-control sampling. For each observed event (case), samples a specified number of non-events (controls) from the risk set.\n\nFields\n\nn_controls::Int: Number of control samples per case\nexclude_self_loops::Bool: Whether to exclude self-loops from sampling\nseed::Union{Int, Nothing}: Random seed for reproducibility\n\n\n\n\n\n","category":"type"},{"location":"api/estimation/#REM.generate_observations","page":"Estimation","title":"REM.generate_observations","text":"generate_observations(seq::EventSequence, stats::Vector{<:AbstractStatistic},\n                      sampler::CaseControlSampler; kwargs...) -> DataFrame\n\nGenerate observations for model estimation using case-control sampling.\n\nArguments\n\nseq::EventSequence: The event sequence to analyze\nstats::Vector{<:AbstractStatistic}: Statistics to compute\nsampler::CaseControlSampler: Sampling configuration\n\nKeyword Arguments\n\nstart_index::Int=1: Index of first event to include\nend_index::Int=length(seq): Index of last event to include\ndecay::Float64=0.0: Exponential decay rate for network state\nat_risk::Union{Nothing, Set{Int}}=nothing: Set of actors \"at risk\" (if nothing, all actors)\n\nReturns\n\nDataFrame: Observations with columns for each statistic, plus is_event and stratum\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.compute_statistics","page":"Estimation","title":"REM.compute_statistics","text":"compute_statistics(seq::EventSequence, stats::Vector{<:AbstractStatistic};\n                   decay::Float64=0.0) -> DataFrame\n\nCompute statistics for all events in a sequence (without sampling controls).\n\nReturns\n\nDataFrame: One row per event with computed statistics\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.fit_rem","page":"Estimation","title":"REM.fit_rem","text":"fit_rem(observations::DataFrame, stat_names::Vector{String}; kwargs...) -> REMResult\n\nFit a relational event model using stratified Cox regression.\n\nArguments\n\nobservations::DataFrame: Output from generate_observations\nstat_names::Vector{String}: Names of statistic columns to include in the model\n\nKeyword Arguments\n\nmaxiter::Int=100: Maximum iterations for optimization\ntol::Float64=1e-8: Convergence tolerance\n\nReturns\n\nREMResult: Fitted model results\n\n\n\n\n\nfit_rem(seq::EventSequence, stats::Vector{<:AbstractStatistic}; kwargs...) -> REMResult\n\nFit a relational event model directly from an event sequence.\n\nArguments\n\nseq::EventSequence: The event sequence\nstats::Vector{<:AbstractStatistic}: Statistics to include in the model\n\nKeyword Arguments\n\nn_controls::Int=100: Number of controls per case\ndecay::Float64=0.0: Exponential decay rate\nexclude_self_loops::Bool=true: Exclude self-loops from risk set\nseed::Union{Int,Nothing}=nothing: Random seed\nmaxiter::Int=100: Maximum iterations\ntol::Float64=1e-8: Convergence tolerance\n\nReturns\n\nREMResult: Fitted model results\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.REMResult","page":"Estimation","title":"REM.REMResult","text":"REMResult\n\nResults from fitting a relational event model.\n\nFields\n\ncoefficients::Vector{Float64}: Estimated coefficients\nstd_errors::Vector{Float64}: Standard errors of coefficients\nz_values::Vector{Float64}: Z-statistics\np_values::Vector{Float64}: P-values (two-sided)\nstat_names::Vector{String}: Names of statistics\nn_events::Int: Number of events in the model\nn_observations::Int: Total number of observations\nlog_likelihood::Float64: Log-likelihood at convergence\nconverged::Bool: Whether the optimization converged\n\n\n\n\n\n","category":"type"},{"location":"api/estimation/#REM.coef","page":"Estimation","title":"REM.coef","text":"coef(result::REMResult) -> Vector{Float64}\n\nExtract coefficients from a fitted model.\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.stderror","page":"Estimation","title":"REM.stderror","text":"stderror(result::REMResult) -> Vector{Float64}\n\nExtract standard errors from a fitted model.\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.coeftable","page":"Estimation","title":"REM.coeftable","text":"coeftable(result::REMResult) -> DataFrame\n\nReturn coefficients as a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.halflife_to_decay","page":"Estimation","title":"REM.halflife_to_decay","text":"halflife_to_decay(halflife::Real) -> Float64\n\nConvert a halflife parameter to an exponential decay rate. The decay rate λ is such that weight = exp(-λ * elapsed_time). At time = halflife, the weight is 0.5.\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.decay_to_halflife","page":"Estimation","title":"REM.decay_to_halflife","text":"decay_to_halflife(decay::Real) -> Float64\n\nConvert an exponential decay rate to a halflife parameter.\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.compute_decay_weight","page":"Estimation","title":"REM.compute_decay_weight","text":"compute_decay_weight(elapsed_time::Real, decay::Real) -> Float64\n\nCompute the exponential decay weight for a given elapsed time.\n\n\n\n\n\n","category":"function"},{"location":"guide/decay/#Temporal-Decay","page":"Temporal Decay","title":"Temporal Decay","text":"REM.jl supports exponential decay of network effects, allowing past events to have diminishing influence over time.","category":"section"},{"location":"guide/decay/#Why-Use-Decay?","page":"Temporal Decay","title":"Why Use Decay?","text":"In many applications, recent events are more relevant than older ones:\n\nA communication last week matters more than one from a year ago\nRelationships may weaken without recent interaction\nNetwork effects fade over time\n\nTemporal decay captures this by down-weighting older events.","category":"section"},{"location":"guide/decay/#Exponential-Decay-Model","page":"Temporal Decay","title":"Exponential Decay Model","text":"The weight of an event decays exponentially:\n\nweight(t) = exp(-λ × elapsed_time)\n\nWhere:\n\nλ is the decay rate\nAt t=0, weight = 1.0\nAt halflife, weight = 0.5","category":"section"},{"location":"guide/decay/#Setting-Decay-Rate","page":"Temporal Decay","title":"Setting Decay Rate","text":"","category":"section"},{"location":"guide/decay/#Using-Halflife","page":"Temporal Decay","title":"Using Halflife","text":"The most intuitive way is to specify a halflife:\n\n# Events lose half their weight after 10 time units\ndecay = halflife_to_decay(10.0)","category":"section"},{"location":"guide/decay/#Direct-Decay-Rate","page":"Temporal Decay","title":"Direct Decay Rate","text":"# Decay rate of 0.1 per time unit\ndecay = 0.1","category":"section"},{"location":"guide/decay/#Converting-Between-Forms","page":"Temporal Decay","title":"Converting Between Forms","text":"decay = halflife_to_decay(halflife)\nhalflife = decay_to_halflife(decay)","category":"section"},{"location":"guide/decay/#Using-Decay-in-Models","page":"Temporal Decay","title":"Using Decay in Models","text":"","category":"section"},{"location":"guide/decay/#With-fit_rem","page":"Temporal Decay","title":"With fit_rem","text":"result = fit_rem(seq, stats;\n    n_controls = 100,\n    decay = halflife_to_decay(10.0),\n    seed = 42\n)","category":"section"},{"location":"guide/decay/#With-NetworkState","page":"Temporal Decay","title":"With NetworkState","text":"# Create state with decay\nstate = NetworkState(seq; decay=halflife_to_decay(10.0))\n\n# Process events - decay is applied automatically\nfor event in seq\n    update!(state, event)\nend","category":"section"},{"location":"guide/decay/#With-generate_observations","page":"Temporal Decay","title":"With generate_observations","text":"sampler = CaseControlSampler(n_controls=100, seed=42)\nobs = generate_observations(seq, stats, sampler;\n    decay = halflife_to_decay(10.0)\n)","category":"section"},{"location":"guide/decay/#Decay-with-Different-Time-Types","page":"Temporal Decay","title":"Decay with Different Time Types","text":"","category":"section"},{"location":"guide/decay/#Numeric-Timestamps","page":"Temporal Decay","title":"Numeric Timestamps","text":"For numeric timestamps, decay is applied directly:\n\n# If time is in hours, halflife of 24 = one day decay\ndecay = halflife_to_decay(24.0)","category":"section"},{"location":"guide/decay/#DateTime-Timestamps","page":"Temporal Decay","title":"DateTime Timestamps","text":"For DateTime, time differences are converted to seconds:\n\nusing Dates\n\nevents = [\n    Event(1, 2, DateTime(2024, 1, 1, 10, 0)),\n    Event(2, 1, DateTime(2024, 1, 1, 11, 0)),\n]\nseq = EventSequence(events)\n\n# Halflife of 1 hour = 3600 seconds\ndecay = halflife_to_decay(3600.0)\nstate = NetworkState(seq; decay=decay)","category":"section"},{"location":"guide/decay/#Date-Timestamps","page":"Temporal Decay","title":"Date Timestamps","text":"For Date, differences are in days (converted to seconds):\n\nevents = [\n    Event(1, 2, Date(2024, 1, 1)),\n    Event(2, 1, Date(2024, 1, 15)),\n]\nseq = EventSequence(events)\n\n# Halflife of 7 days = 7 * 86400 seconds\ndecay = halflife_to_decay(7.0 * 86400)","category":"section"},{"location":"guide/decay/#How-Decay-Affects-Statistics","page":"Temporal Decay","title":"How Decay Affects Statistics","text":"","category":"section"},{"location":"guide/decay/#Dyad-Counts","page":"Temporal Decay","title":"Dyad Counts","text":"Without decay:\n\nget_dyad_count(state, s, r) = total number of s→r events\n\nWith decay:\n\nget_dyad_count(state, s, r) = Σ exp(-λ × (current_time - event_time))","category":"section"},{"location":"guide/decay/#Degrees","page":"Temporal Decay","title":"Degrees","text":"Out-degree and in-degree are similarly weighted:\n\nout_degree(actor) = Σ decay_weight × event_weight","category":"section"},{"location":"guide/decay/#Example","page":"Temporal Decay","title":"Example","text":"using REM\n\nevents = [\n    Event(1, 2, 0.0),\n    Event(1, 2, 10.0),  # 10 time units later\n]\nseq = EventSequence(events)\n\n# Halflife of 10\ndecay = halflife_to_decay(10.0)\nstate = NetworkState(seq; decay=decay)\n\n# After first event\nupdate!(state, seq[1])\nprintln(get_dyad_count(state, 1, 2))  # 1.0\n\n# After second event (first event decayed to 0.5)\nupdate!(state, seq[2])\nprintln(get_dyad_count(state, 1, 2))  # 1.5 (0.5 + 1.0)","category":"section"},{"location":"guide/decay/#Choosing-Halflife","page":"Temporal Decay","title":"Choosing Halflife","text":"The appropriate halflife depends on your domain:\n\nDomain Typical Halflife\nEmail/messaging Hours to days\nSocial interactions Days to weeks\nBusiness relationships Weeks to months\nOrganizational ties Months to years","category":"section"},{"location":"guide/decay/#Guidelines","page":"Temporal Decay","title":"Guidelines","text":"Domain knowledge: What timeframe makes interactions \"stale\"?\nEvent frequency: Halflife should be comparable to typical inter-event times\nSensitivity analysis: Try different values and compare results","category":"section"},{"location":"guide/decay/#Recency-Statistic","page":"Temporal Decay","title":"Recency Statistic","text":"For dyad-specific recency effects, use RecencyStatistic:\n\n# Inverse of time since last event\nRecencyStatistic(transform=:inverse)\n\n# With exponential decay\nRecencyStatistic(transform=:exp_decay, decay=0.1)\n\n# Log transform\nRecencyStatistic(transform=:log)\n\nThis is different from global decay:\n\nGlobal decay: Affects all statistics through NetworkState\nRecencyStatistic: A specific statistic measuring time since last dyad event","category":"section"},{"location":"guide/decay/#Combining-Approaches","page":"Temporal Decay","title":"Combining Approaches","text":"You can use both:\n\nstats = [\n    Repetition(),           # Affected by global decay\n    Reciprocity(),          # Affected by global decay\n    RecencyStatistic(),     # Additional dyad-specific recency effect\n]\n\nresult = fit_rem(seq, stats;\n    n_controls = 100,\n    decay = halflife_to_decay(10.0),  # Global decay\n    seed = 42\n)\n\nThis allows modeling both:\n\nGeneral decay of all network effects\nSpecific recency effects for focal dyads","category":"section"},{"location":"guide/events/#Events-and-Data","page":"Events and Data","title":"Events and Data","text":"This guide covers how to work with relational event data in REM.jl.","category":"section"},{"location":"guide/events/#Events","page":"Events and Data","title":"Events","text":"An Event represents a single directed interaction:\n\n# Basic event: sender, receiver, time\ne = Event(1, 2, 1.0)\n\n# With optional event type and weight\ne = Event(1, 2, 1.0; eventtype=:email, weight=2.0)","category":"section"},{"location":"guide/events/#Event-Fields","page":"Events and Data","title":"Event Fields","text":"sender::Int - ID of the event sender\nreceiver::Int - ID of the event receiver\ntime::T - Timestamp (can be Float64, Int, DateTime, or Date)\neventtype::Symbol - Category of the event (default: :event)\nweight::Float64 - Weight/magnitude (default: 1.0)","category":"section"},{"location":"guide/events/#Timestamp-Types","page":"Events and Data","title":"Timestamp Types","text":"REM.jl supports various timestamp types:\n\nusing Dates\n\n# Numeric timestamps\nEvent(1, 2, 1.0)         # Float64\nEvent(1, 2, 1)           # Int\n\n# Calendar timestamps\nEvent(1, 2, DateTime(2024, 1, 15, 10, 30))  # DateTime\nEvent(1, 2, Date(2024, 1, 15))              # Date","category":"section"},{"location":"guide/events/#Event-Sequences","page":"Events and Data","title":"Event Sequences","text":"An EventSequence is a time-sorted collection of events:\n\nevents = [\n    Event(1, 2, 3.0),  # Not in order...\n    Event(2, 1, 1.0),\n    Event(1, 3, 2.0),\n]\nseq = EventSequence(events)  # Automatically sorted by time\n\n# Access events\nseq[1]              # First event (time=1.0)\nlength(seq)         # Number of events\nseq.n_actors        # Number of unique actors\nseq.actors          # Set of actor IDs","category":"section"},{"location":"guide/events/#Adding-Events","page":"Events and Data","title":"Adding Events","text":"# Events are inserted in time order\npush!(seq, Event(3, 1, 1.5))","category":"section"},{"location":"guide/events/#Loading-Data","page":"Events and Data","title":"Loading Data","text":"","category":"section"},{"location":"guide/events/#From-DataFrame","page":"Events and Data","title":"From DataFrame","text":"using DataFrames\n\ndf = DataFrame(\n    sender = [1, 2, 1],\n    receiver = [2, 1, 3],\n    time = [1.0, 2.0, 3.0]\n)\n\nseq = load_events(df)","category":"section"},{"location":"guide/events/#Custom-Column-Names","page":"Events and Data","title":"Custom Column Names","text":"df = DataFrame(\n    from = [1, 2, 1],\n    to = [2, 1, 3],\n    timestamp = [1.0, 2.0, 3.0],\n    type = [:email, :email, :meeting],\n    importance = [1.0, 2.0, 1.5]\n)\n\nseq = load_events(df;\n    sender_col = :from,\n    receiver_col = :to,\n    time_col = :timestamp,\n    type_col = :type,\n    weight_col = :importance\n)","category":"section"},{"location":"guide/events/#String-Actor-Names","page":"Events and Data","title":"String Actor Names","text":"When actors are identified by names rather than numeric IDs:\n\ndf = DataFrame(\n    sender = [\"Alice\", \"Bob\", \"Alice\"],\n    receiver = [\"Bob\", \"Alice\", \"Carol\"],\n    time = [1.0, 2.0, 3.0]\n)\n\nseq = load_events(df; actor_names=true)\n# Actors are assigned numeric IDs internally","category":"section"},{"location":"guide/events/#From-CSV-File","page":"Events and Data","title":"From CSV File","text":"seq = load_events(\"events.csv\")\n\n# With options\nseq = load_events(\"events.csv\";\n    sender_col = :source,\n    receiver_col = :target,\n    time_col = :timestamp,\n    actor_names = true\n)","category":"section"},{"location":"guide/events/#DateTime-Parsing","page":"Events and Data","title":"DateTime Parsing","text":"df = DataFrame(\n    sender = [1, 2, 1],\n    receiver = [2, 1, 3],\n    time = [\"2024-01-01T10:00:00\", \"2024-01-01T11:00:00\", \"2024-01-01T12:00:00\"]\n)\n\nseq = load_events(df; time_type=DateTime)","category":"section"},{"location":"guide/events/#Node-Attributes","page":"Events and Data","title":"Node Attributes","text":"Node attributes store actor-level covariates:\n\n# Create an attribute\ngender = NodeAttribute(:gender,\n    Dict(1 => \"M\", 2 => \"F\", 3 => \"M\"),  # Actor ID → value\n    \"Unknown\"                             # Default value\n)\n\n# Access values\ngender[1]  # \"M\"\ngender[4]  # \"Unknown\" (default)\n\n# Create numeric attribute\nage = NodeAttribute(:age,\n    Dict(1 => 25.0, 2 => 30.0, 3 => 28.0),\n    0.0\n)","category":"section"},{"location":"guide/events/#Actor-Sets","page":"Events and Data","title":"Actor Sets","text":"For specifying custom risk sets:\n\n# From numeric IDs\nactors = ActorSet([1, 2, 3, 4, 5])\n\n# From names (creates ID mapping)\nactors = ActorSet([\"Alice\", \"Bob\", \"Carol\"])\nactors.name_to_id[\"Alice\"]  # 1\nactors.id_to_name[1]        # \"Alice\"","category":"section"},{"location":"guide/events/#Risk-Sets","page":"Events and Data","title":"Risk Sets","text":"Risk sets define which dyads could potentially experience an event:\n\nrs = RiskSet(\n    event_index,                    # Index of focal event\n    [1, 2, 3],                      # Potential senders\n    [1, 2, 3, 4];                   # Potential receivers\n    exclude_self_loops = true       # Exclude s == r\n)\n\nn_dyads(rs)  # Number of dyads in risk set","category":"section"},{"location":"guide/events/#Utility-Functions","page":"Events and Data","title":"Utility Functions","text":"","category":"section"},{"location":"guide/events/#Time-Windows","page":"Events and Data","title":"Time Windows","text":"# Get events before a specific index\nevents_before(seq, 5)  # View of events 1:4\n\n# Get events in a time window\nevents_in_window(seq, 5, 10.0)  # Events within 10 time units before event 5","category":"section"},{"location":"guide/events/#Decay-Conversion","page":"Events and Data","title":"Decay Conversion","text":"# Convert halflife to decay rate\ndecay = halflife_to_decay(10.0)  # λ such that weight = 0.5 at t = 10\n\n# Convert back\nhalflife = decay_to_halflife(decay)","category":"section"},{"location":"guide/statistics/#Statistics","page":"Statistics","title":"Statistics","text":"Statistics in REM.jl capture different mechanisms that may drive event occurrence. All statistics implement a common interface:\n\ncompute(stat, state, sender, receiver) -> Float64\nname(stat) -> String","category":"section"},{"location":"guide/statistics/#Statistic-Types","page":"Statistics","title":"Statistic Types","text":"REM.jl organizes statistics into categories:\n\nType Description\nDyadStatistic History between sender and receiver\nDegreeStatistic Actor activity and popularity\nTriangleStatistic Triadic closure effects\nFourCycleStatistic Four-cycle clustering effects\nNodeStatistic Node attribute effects","category":"section"},{"location":"guide/statistics/#Dyad-Statistics","page":"Statistics","title":"Dyad Statistics","text":"These capture the history of events between the focal sender-receiver pair.","category":"section"},{"location":"guide/statistics/#Repetition","page":"Statistics","title":"Repetition","text":"Tendency to repeat past interactions:\n\n# Count of past s→r events\nRepetition()\n\n# Undirected: count of s↔r events\nRepetition(directed=false)","category":"section"},{"location":"guide/statistics/#Reciprocity","page":"Statistics","title":"Reciprocity","text":"Tendency to reciprocate interactions:\n\n# Count of past r→s events\nReciprocity()","category":"section"},{"location":"guide/statistics/#Inertia","page":"Statistics","title":"Inertia","text":"Combined repetition and reciprocity:\n\n# Default: equal weights\nInertiaStatistic()\n\n# Custom weights\nInertiaStatistic(repetition_weight=2.0, reciprocity_weight=1.0)","category":"section"},{"location":"guide/statistics/#Recency","page":"Statistics","title":"Recency","text":"How recently the last event occurred:\n\n# Inverse of elapsed time\nRecencyStatistic()\n\n# With different transforms\nRecencyStatistic(transform=:inverse)    # 1/elapsed\nRecencyStatistic(transform=:log)        # 1/log(1+elapsed)\nRecencyStatistic(transform=:exp_decay, decay=0.1)  # exp(-0.1*elapsed)","category":"section"},{"location":"guide/statistics/#Dyad-Covariate","page":"Statistics","title":"Dyad Covariate","text":"Pre-specified dyad-level covariate:\n\n# Distance between actors\ndistances = Dict((1,2) => 10.0, (1,3) => 20.0, (2,3) => 15.0)\nDyadCovariate(distances; default=100.0, name=\"distance\")","category":"section"},{"location":"guide/statistics/#Degree-Statistics","page":"Statistics","title":"Degree Statistics","text":"These capture actor activity (out-degree) and popularity (in-degree).","category":"section"},{"location":"guide/statistics/#Activity-(Out-degree)","page":"Statistics","title":"Activity (Out-degree)","text":"SenderActivity()     # Sender's past sending activity\nReceiverActivity()   # Receiver's past sending activity","category":"section"},{"location":"guide/statistics/#Popularity-(In-degree)","page":"Statistics","title":"Popularity (In-degree)","text":"SenderPopularity()   # Sender's past receiving (popularity)\nReceiverPopularity() # Receiver's past receiving (popularity)","category":"section"},{"location":"guide/statistics/#Total-Degree","page":"Statistics","title":"Total Degree","text":"TotalDegree(role=:sender)    # Sender's in + out degree\nTotalDegree(role=:receiver)  # Receiver's in + out degree","category":"section"},{"location":"guide/statistics/#Degree-Difference","page":"Statistics","title":"Degree Difference","text":"DegreeDifference()                        # Sender out-degree - Receiver out-degree\nDegreeDifference(degree_type=:in)         # In-degree difference\nDegreeDifference(degree_type=:total)      # Total degree difference\nDegreeDifference(absolute=true)           # Absolute difference","category":"section"},{"location":"guide/statistics/#Log-Degree","page":"Statistics","title":"Log Degree","text":"LogDegree(role=:sender, degree_type=:out)   # log(1 + sender out-degree)\nLogDegree(role=:receiver, degree_type=:in)  # log(1 + receiver in-degree)","category":"section"},{"location":"guide/statistics/#Triangle-Statistics","page":"Statistics","title":"Triangle Statistics","text":"These capture triadic closure - the tendency for events to \"close\" triangles.","category":"section"},{"location":"guide/statistics/#Transitive-Closure","page":"Statistics","title":"Transitive Closure","text":"Events that close a two-path s→k→r:\n\n# Count of k where s→k and k→r\nTransitiveClosure()\n\n# Weighted by minimum edge weight\nTransitiveClosure(weighted=true)\n\nVisual representation:\n\n  k\n ↗ ↘\ns → r  (the new event closes the triangle)","category":"section"},{"location":"guide/statistics/#Cyclic-Closure","page":"Statistics","title":"Cyclic Closure","text":"Events that form a cycle r→k→s:\n\n# Count of k where r→k and k→s\nCyclicClosure()\n\nVisual representation:\n\n  k\n ↗ ↙\nr ← s  (the new s→r event closes the cycle)","category":"section"},{"location":"guide/statistics/#Shared-Sender","page":"Statistics","title":"Shared Sender","text":"Common sender k who sent to both s and r:\n\n# Count of k where k→s and k→r\nSharedSender()","category":"section"},{"location":"guide/statistics/#Shared-Receiver","page":"Statistics","title":"Shared Receiver","text":"Common receiver k who received from both s and r:\n\n# Count of k where s→k and r→k\nSharedReceiver()","category":"section"},{"location":"guide/statistics/#Common-Neighbors-(Undirected)","page":"Statistics","title":"Common Neighbors (Undirected)","text":"# Any common neighbor (regardless of direction)\nCommonNeighbors()","category":"section"},{"location":"guide/statistics/#Geometrically-Weighted-Triads","page":"Statistics","title":"Geometrically Weighted Triads","text":"Down-weights additional shared partners:\n\nGeometricWeightedTriads(closure_type=:transitive, alpha=0.5)\nGeometricWeightedTriads(closure_type=:cyclic, alpha=0.5)\nGeometricWeightedTriads(closure_type=:shared_sender, alpha=0.5)\nGeometricWeightedTriads(closure_type=:shared_receiver, alpha=0.5)","category":"section"},{"location":"guide/statistics/#Four-Cycle-Statistics","page":"Statistics","title":"Four-Cycle Statistics","text":"These capture clustering through pairs of intermediaries.","category":"section"},{"location":"guide/statistics/#Four-Cycle","page":"Statistics","title":"Four-Cycle","text":"Various four-cycle configurations:\n\n# s→j←k→r (shared out-neighbor pattern)\nFourCycle(cycle_type=:out_out)\n\n# s←j→k←r (shared in-neighbor pattern)\nFourCycle(cycle_type=:in_in)\n\n# s→j→k→r (chain pattern)\nFourCycle(cycle_type=:out_in)\n\n# s←j←k←r (reverse chain)\nFourCycle(cycle_type=:in_out)\n\n# All patterns combined\nFourCycle(cycle_type=:mixed)","category":"section"},{"location":"guide/statistics/#Geometrically-Weighted-Four-Cycles","page":"Statistics","title":"Geometrically Weighted Four-Cycles","text":"GeometricWeightedFourCycles(cycle_type=:out_out, alpha=0.5)","category":"section"},{"location":"guide/statistics/#Node-Attribute-Statistics","page":"Statistics","title":"Node Attribute Statistics","text":"These incorporate actor-level attributes.","category":"section"},{"location":"guide/statistics/#Homophily-(Node-Match)","page":"Statistics","title":"Homophily (Node Match)","text":"Indicator for matching attributes:\n\ngender = NodeAttribute(:gender, Dict(1=>\"M\", 2=>\"F\", 3=>\"M\"), \"Unknown\")\n\n# Returns 1.0 if sender and receiver have same gender\nNodeMatch(gender)","category":"section"},{"location":"guide/statistics/#Mixing-Patterns-(Node-Mix)","page":"Statistics","title":"Mixing Patterns (Node Mix)","text":"Indicator for specific sender-receiver combinations:\n\n# Returns 1.0 if sender is \"M\" and receiver is \"F\"\nNodeMix(gender, \"M\", \"F\")","category":"section"},{"location":"guide/statistics/#Attribute-Difference","page":"Statistics","title":"Attribute Difference","text":"For numeric attributes:\n\nage = NodeAttribute(:age, Dict(1=>25.0, 2=>30.0), 0.0)\n\n# sender_age - receiver_age\nNodeDifference(age)\n\n# |sender_age - receiver_age|\nNodeDifference(age; absolute=true)","category":"section"},{"location":"guide/statistics/#Attribute-Sum-and-Product","page":"Statistics","title":"Attribute Sum and Product","text":"NodeSum(age)      # sender_age + receiver_age\nNodeProduct(age)  # sender_age * receiver_age","category":"section"},{"location":"guide/statistics/#Main-Effects","page":"Statistics","title":"Main Effects","text":"Include attribute as a main effect:\n\n# Numeric attributes\nSenderAttribute(age)    # Sender's age\nReceiverAttribute(age)  # Receiver's age\n\n# Categorical attributes (indicator for specific value)\nSenderCategorical(gender, \"M\")    # 1.0 if sender is \"M\"\nReceiverCategorical(gender, \"F\")  # 1.0 if receiver is \"F\"","category":"section"},{"location":"guide/statistics/#Using-Statistics","page":"Statistics","title":"Using Statistics","text":"","category":"section"},{"location":"guide/statistics/#Creating-a-Model","page":"Statistics","title":"Creating a Model","text":"stats = [\n    Repetition(),\n    Reciprocity(),\n    SenderActivity(),\n    ReceiverPopularity(),\n    TransitiveClosure(),\n    NodeMatch(gender),\n]","category":"section"},{"location":"guide/statistics/#Computing-Statistics-Manually","page":"Statistics","title":"Computing Statistics Manually","text":"# Create network state\nstate = NetworkState(seq)\n\n# Process some events\nfor i in 1:5\n    update!(state, seq[i])\nend\n\n# Compute a statistic for a potential event\nrep = Repetition()\nvalue = compute(rep, state, sender_id, receiver_id)\n\n# Compute all statistics\nvalues = compute_all(stats, state, sender_id, receiver_id)","category":"section"},{"location":"guide/statistics/#Custom-Names","page":"Statistics","title":"Custom Names","text":"All statistics accept a name parameter:\n\nRepetition(name=\"past_interactions\")\nTransitiveClosure(name=\"friends_of_friends\")","category":"section"},{"location":"api/statistics/#Statistics-API-Reference","page":"Statistics","title":"Statistics API Reference","text":"","category":"section"},{"location":"api/statistics/#Base-Types-and-Interface","page":"Statistics","title":"Base Types and Interface","text":"","category":"section"},{"location":"api/statistics/#Dyad-Statistics","page":"Statistics","title":"Dyad Statistics","text":"","category":"section"},{"location":"api/statistics/#Degree-Statistics","page":"Statistics","title":"Degree Statistics","text":"","category":"section"},{"location":"api/statistics/#Triangle-Statistics","page":"Statistics","title":"Triangle Statistics","text":"","category":"section"},{"location":"api/statistics/#Four-Cycle-Statistics","page":"Statistics","title":"Four-Cycle Statistics","text":"","category":"section"},{"location":"api/statistics/#Node-Attribute-Statistics","page":"Statistics","title":"Node Attribute Statistics","text":"","category":"section"},{"location":"api/statistics/#REM.AbstractStatistic","page":"Statistics","title":"REM.AbstractStatistic","text":"AbstractStatistic\n\nAbstract base type for all REM statistics.\n\nAll statistics must implement:\n\ncompute(stat::AbstractStatistic, state::NetworkState, sender::Int, receiver::Int) -> Float64\nname(stat::AbstractStatistic) -> String\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.DyadStatistic","page":"Statistics","title":"REM.DyadStatistic","text":"DyadStatistic <: AbstractStatistic\n\nStatistics that depend on the history of events between the focal dyad (sender, receiver). Examples: repetition, reciprocity, inertia.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.DegreeStatistic","page":"Statistics","title":"REM.DegreeStatistic","text":"DegreeStatistic <: AbstractStatistic\n\nStatistics that depend on the degree (activity/popularity) of actors. Examples: sender activity, receiver popularity.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.TriangleStatistic","page":"Statistics","title":"REM.TriangleStatistic","text":"TriangleStatistic <: AbstractStatistic\n\nStatistics that measure triadic closure effects. Examples: transitive closure, cyclic closure, shared partners.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.FourCycleStatistic","page":"Statistics","title":"REM.FourCycleStatistic","text":"FourCycleStatistic <: AbstractStatistic\n\nStatistics that measure four-cycle (local clustering) effects.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.NodeStatistic","page":"Statistics","title":"REM.NodeStatistic","text":"NodeStatistic <: AbstractStatistic\n\nStatistics based on node-level attributes. Examples: homophily, attribute matching.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.InteractionStatistic","page":"Statistics","title":"REM.InteractionStatistic","text":"InteractionStatistic <: AbstractStatistic\n\nStatistics that capture interaction effects between attributes.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.compute","page":"Statistics","title":"REM.compute","text":"compute(stat::AbstractStatistic, state::NetworkState, sender::Int, receiver::Int) -> Float64\n\nCompute the statistic value for a potential event from sender to receiver. This is the main interface that all statistics must implement.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#REM.name","page":"Statistics","title":"REM.name","text":"name(stat::AbstractStatistic) -> String\n\nReturn a descriptive name for the statistic.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#REM.StatisticSet","page":"Statistics","title":"REM.StatisticSet","text":"StatisticSet\n\nA collection of statistics to compute together.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.compute_all","page":"Statistics","title":"REM.compute_all","text":"compute_all(ss::StatisticSet, state::NetworkState, sender::Int, receiver::Int) -> Vector{Float64}\n\nCompute all statistics in the set for a potential event.\n\n\n\n\n\ncompute_all(stats::Vector{<:AbstractStatistic}, state::NetworkState, sender::Int, receiver::Int) -> Vector{Float64}\n\nCompute all statistics for a potential event.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#REM.Repetition","page":"Statistics","title":"REM.Repetition","text":"Repetition <: DyadStatistic\n\nMeasures the tendency for repeated events from sender to receiver. Returns the (weighted) count of past events from sender to receiver.\n\nFields\n\ndirected::Bool: If true, count only events from s→r. If false, count events in both directions.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.Reciprocity","page":"Statistics","title":"REM.Reciprocity","text":"Reciprocity <: DyadStatistic\n\nMeasures the tendency for reciprocal events. Returns the (weighted) count of past events from receiver to sender.\n\nFields\n\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.InertiaStatistic","page":"Statistics","title":"REM.InertiaStatistic","text":"InertiaStatistic <: DyadStatistic\n\nMeasures inertia - the tendency for events to persist in a direction. Combines repetition and reciprocity effects.\n\nReturns: repetitionweight * repetition + reciprocityweight * reciprocity\n\nFields\n\nrepetition_weight::Float64: Weight for repetition component.\nreciprocity_weight::Float64: Weight for reciprocity component.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.RecencyStatistic","page":"Statistics","title":"REM.RecencyStatistic","text":"RecencyStatistic <: DyadStatistic\n\nMeasures recency - how recently the last event occurred on this dyad. Returns the inverse of elapsed time since last event (or 0 if no prior events).\n\nFields\n\ndirected::Bool: If true, only consider events from s→r.\ntransform::Symbol: Transform to apply (:inverse, :log, :exp_decay).\ndecay::Float64: Decay parameter for :exp_decay transform.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.DyadCovariate","page":"Statistics","title":"REM.DyadCovariate","text":"DyadCovariate <: DyadStatistic\n\nA statistic based on a pre-specified dyad-level covariate matrix.\n\nFields\n\nvalues::Dict{Tuple{Int,Int}, Float64}: Mapping from dyad to covariate value.\ndefault::Float64: Default value for dyads not in the dict.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.SenderActivity","page":"Statistics","title":"REM.SenderActivity","text":"SenderActivity <: DegreeStatistic\n\nMeasures the sender's past activity (out-degree). Returns the (weighted) number of past events sent by the sender.\n\nFields\n\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.ReceiverActivity","page":"Statistics","title":"REM.ReceiverActivity","text":"ReceiverActivity <: DegreeStatistic\n\nMeasures the receiver's past activity (out-degree). Returns the (weighted) number of past events sent by the receiver.\n\nFields\n\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.SenderPopularity","page":"Statistics","title":"REM.SenderPopularity","text":"SenderPopularity <: DegreeStatistic\n\nMeasures the sender's past popularity (in-degree). Returns the (weighted) number of past events received by the sender.\n\nFields\n\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.ReceiverPopularity","page":"Statistics","title":"REM.ReceiverPopularity","text":"ReceiverPopularity <: DegreeStatistic\n\nMeasures the receiver's past popularity (in-degree). Returns the (weighted) number of past events received by the receiver.\n\nFields\n\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.TotalDegree","page":"Statistics","title":"REM.TotalDegree","text":"TotalDegree <: DegreeStatistic\n\nMeasures the total degree (in + out) of an actor.\n\nFields\n\nrole::Symbol: Which actor's degree to compute (:sender or :receiver).\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.DegreeDifference","page":"Statistics","title":"REM.DegreeDifference","text":"DegreeDifference <: DegreeStatistic\n\nMeasures the difference in degree between sender and receiver.\n\nFields\n\ndegree_type::Symbol: Type of degree to compare (:out, :in, or :total).\nabsolute::Bool: If true, return absolute difference.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.LogDegree","page":"Statistics","title":"REM.LogDegree","text":"LogDegree <: DegreeStatistic\n\nMeasures the log-transformed degree of an actor. Uses log(1 + degree) to handle zero degrees.\n\nFields\n\nrole::Symbol: Which actor's degree to compute (:sender or :receiver).\ndegree_type::Symbol: Type of degree (:out, :in, or :total).\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.TransitiveClosure","page":"Statistics","title":"REM.TransitiveClosure","text":"TransitiveClosure <: TriangleStatistic\n\nMeasures transitive closure: tendency for s→r when there exists k such that s→k→r. Returns the count of actors k who have received from s and sent to r.\n\nFields\n\nweighted::Bool: If true, weight by edge weights.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.CyclicClosure","page":"Statistics","title":"REM.CyclicClosure","text":"CyclicClosure <: TriangleStatistic\n\nMeasures cyclic closure: tendency for s→r when there exists k such that r→k→s. Returns the count of actors k who have received from r and sent to s.\n\nFields\n\nweighted::Bool: If true, weight by edge weights.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.SharedSender","page":"Statistics","title":"REM.SharedSender","text":"SharedSender <: TriangleStatistic\n\nMeasures shared sender effect: tendency for s→r when there exists k such that k→s and k→r. Returns the count of actors k who have sent to both s and r.\n\nFields\n\nweighted::Bool: If true, weight by edge weights.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.SharedReceiver","page":"Statistics","title":"REM.SharedReceiver","text":"SharedReceiver <: TriangleStatistic\n\nMeasures shared receiver effect: tendency for s→r when there exists k such that s→k and r→k. Returns the count of actors k who have received from both s and r.\n\nFields\n\nweighted::Bool: If true, weight by edge weights.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.CommonNeighbors","page":"Statistics","title":"REM.CommonNeighbors","text":"CommonNeighbors <: TriangleStatistic\n\nMeasures the number of common neighbors (undirected) between sender and receiver.\n\nFields\n\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.GeometricWeightedTriads","page":"Statistics","title":"REM.GeometricWeightedTriads","text":"GeometricWeightedTriads <: TriangleStatistic\n\nGeometrically weighted shared partner statistic. Down-weights the contribution of additional shared partners.\n\nFields\n\nclosure_type::Symbol: Type of closure (:transitive, :cyclic, :sharedsender, :sharedreceiver).\nalpha::Float64: Decay parameter (higher = less down-weighting).\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.FourCycle","page":"Statistics","title":"REM.FourCycle","text":"FourCycle <: FourCycleStatistic\n\nMeasures four-cycle closure: tendency for s→r when there exist j, k such that s→j, k→j, and k→r (or variants).\n\nThis captures local clustering where sender and receiver share connections to a common pair of intermediaries.\n\nFields\n\ncycle_type::Symbol: Type of four-cycle configuration.\n:out_out: s→j←k→r (shared out-neighbor pattern)\n:in_in: s←j→k←r (shared in-neighbor pattern)\n:out_in: s→j→k→r (two-path through intermediaries)\n:mixed: any configuration\nweighted::Bool: If true, weight by edge weights.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.GeometricWeightedFourCycles","page":"Statistics","title":"REM.GeometricWeightedFourCycles","text":"GeometricWeightedFourCycles <: FourCycleStatistic\n\nGeometrically weighted four-cycle statistic. Down-weights the contribution of additional four-cycles.\n\nFields\n\ncycle_type::Symbol: Type of four-cycle configuration.\nalpha::Float64: Decay parameter (higher = less down-weighting).\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.NodeMatch","page":"Statistics","title":"REM.NodeMatch","text":"NodeMatch <: NodeStatistic\n\nMeasures homophily: tendency for events between actors with matching attributes. Returns 1.0 if sender and receiver have the same attribute value, 0.0 otherwise.\n\nFields\n\nattribute::NodeAttribute: The attribute to match on.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.NodeMix","page":"Statistics","title":"REM.NodeMix","text":"NodeMix <: NodeStatistic\n\nMeasures mixing patterns: indicator for specific sender-receiver attribute combinations. Returns 1.0 if sender has value sender_value and receiver has receiver_value.\n\nFields\n\nattribute::NodeAttribute: The attribute to check.\nsender_value: Required sender attribute value.\nreceiver_value: Required receiver attribute value.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.NodeDifference","page":"Statistics","title":"REM.NodeDifference","text":"NodeDifference <: NodeStatistic\n\nMeasures the difference in a numeric attribute between sender and receiver.\n\nFields\n\nattribute::NodeAttribute{<:Number}: The numeric attribute.\nabsolute::Bool: If true, return absolute difference.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.NodeSum","page":"Statistics","title":"REM.NodeSum","text":"NodeSum <: NodeStatistic\n\nMeasures the sum of a numeric attribute for sender and receiver.\n\nFields\n\nattribute::NodeAttribute{<:Number}: The numeric attribute.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.NodeProduct","page":"Statistics","title":"REM.NodeProduct","text":"NodeProduct <: NodeStatistic\n\nMeasures the product of a numeric attribute for sender and receiver.\n\nFields\n\nattribute::NodeAttribute{<:Number}: The numeric attribute.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.SenderAttribute","page":"Statistics","title":"REM.SenderAttribute","text":"SenderAttribute <: NodeStatistic\n\nReturns the sender's attribute value (as a main effect).\n\nFields\n\nattribute::NodeAttribute{<:Number}: The numeric attribute.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.ReceiverAttribute","page":"Statistics","title":"REM.ReceiverAttribute","text":"ReceiverAttribute <: NodeStatistic\n\nReturns the receiver's attribute value (as a main effect).\n\nFields\n\nattribute::NodeAttribute{<:Number}: The numeric attribute.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.SenderCategorical","page":"Statistics","title":"REM.SenderCategorical","text":"SenderCategorical <: NodeStatistic\n\nReturns 1.0 if sender has a specific categorical attribute value.\n\nFields\n\nattribute::NodeAttribute: The categorical attribute.\nvalue: The value to match.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.ReceiverCategorical","page":"Statistics","title":"REM.ReceiverCategorical","text":"ReceiverCategorical <: NodeStatistic\n\nReturns 1.0 if receiver has a specific categorical attribute value.\n\nFields\n\nattribute::NodeAttribute: The categorical attribute.\nvalue: The value to match.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"#REM.jl","page":"Home","title":"REM.jl","text":"Relational Event Models for Julia\n\nREM.jl is a Julia implementation for statistical analysis of relational event networks. It is a port of eventnet.","category":"section"},{"location":"#What-are-Relational-Event-Models?","page":"Home","title":"What are Relational Event Models?","text":"Relational Event Models (REM) are statistical models for analyzing sequences of time-stamped relational events. An event is a directed interaction from a sender to a receiver at a specific point in time. REMs help uncover factors explaining why certain actors interact at higher rates than others.","category":"section"},{"location":"#Key-Concepts","page":"Home","title":"Key Concepts","text":"Relational Event: A time-stamped directed interaction (sender → receiver)\nEvent Sequence: A chronologically ordered sequence of relational events\nNetwork State: The cumulative state of interactions up to a point in time\nStatistics: Computed features that predict event occurrence","category":"section"},{"location":"#Applications","page":"Home","title":"Applications","text":"REMs are widely used in:\n\nSocial network analysis\nCommunication networks (email, messaging)\nOrganizational studies\nInternational relations\nAnimal behavior studies","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Efficient computation: Incremental network state updates for fast statistic calculation\nRich statistic library: Dyadic, degree, triadic, four-cycle, and node attribute statistics\nTemporal decay: Support for exponential decay of network effects\nCase-control sampling: Efficient estimation for large networks\nFlexible data input: Load events from DataFrames or CSV files","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/simoneSantoni/REM.jl\")","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"using REM\n\n# Create events\nevents = [\n    Event(1, 2, 1.0),\n    Event(2, 1, 2.0),\n    Event(1, 3, 3.0),\n]\nseq = EventSequence(events)\n\n# Define model statistics\nstats = [Repetition(), Reciprocity(), SenderActivity()]\n\n# Fit model\nresult = fit_rem(seq, stats; n_controls=100, seed=42)\nprintln(result)","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\n    \"getting_started.md\",\n    \"guide/events.md\",\n    \"guide/statistics.md\",\n    \"guide/estimation.md\",\n    \"guide/decay.md\",\n    \"api/types.md\",\n    \"api/statistics.md\",\n    \"api/estimation.md\",\n]\nDepth = 2","category":"section"},{"location":"#References","page":"Home","title":"References","text":"Butts, C. T. (2008). A relational event framework for social action. Sociological Methodology, 38(1), 155-200.\nLerner, J., & Lomi, A. (2020). Reliability of relational event model estimates under sampling. Network Science, 8(1), 97-135.","category":"section"}]
}
