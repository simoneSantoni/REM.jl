var documenterSearchIndex = {"docs":
[{"location":"guide/estimation/#Model-Estimation","page":"Model Estimation","title":"Model Estimation","text":"REM.jl estimates relational event models using case-control sampling with stratified conditional logistic regression. This approach is equivalent to Cox proportional hazards for survival data and enables efficient estimation even for large networks.","category":"section"},{"location":"guide/estimation/#Overview","page":"Model Estimation","title":"Overview","text":"The estimation process follows three steps:\n\nCase-Control Sampling: For each observed event, sample non-events from the risk set\nStatistic Computation: Calculate statistics for cases and controls\nMaximum Likelihood Estimation: Fit stratified conditional logistic regression","category":"section"},{"location":"guide/estimation/#Why-Case-Control-Sampling?","page":"Model Estimation","title":"Why Case-Control Sampling?","text":"For a network with n actors, there are n(n-1) possible directed dyads at each time point. Computing statistics for all dyads at all time points is often computationally infeasible.\n\nCase-control sampling solves this by:\n\nTreating observed events as \"cases\"\nSampling a subset of non-events as \"controls\"\nUsing stratified estimation to obtain consistent parameter estimates\n\nThis approach is statistically valid and dramatically reduces computation time.","category":"section"},{"location":"guide/estimation/#Configuring-the-Sampler","page":"Model Estimation","title":"Configuring the Sampler","text":"sampler = CaseControlSampler(\n    n_controls = 100,         # Controls per case\n    exclude_self_loops = true, # Exclude s→s from risk set\n    seed = 42                  # Random seed for reproducibility\n)","category":"section"},{"location":"guide/estimation/#Parameters","page":"Model Estimation","title":"Parameters","text":"Parameter Description Default\nn_controls Number of controls sampled per case Required\nexclude_self_loops Whether to exclude self-events true\nseed Random seed (nothing = random each time) nothing","category":"section"},{"location":"guide/estimation/#Choosing-Number-of-Controls","page":"Model Estimation","title":"Choosing Number of Controls","text":"The number of controls affects estimation accuracy and computation time:\n\nn_controls Use Case\n20-50 Quick exploratory analysis\n50-100 Standard analysis\n100-200 Final results, publication\n200+ Very precise estimates needed\n\nMore controls = more accurate standard errors, but diminishing returns beyond ~100-200.","category":"section"},{"location":"guide/estimation/#Generating-Observations","page":"Model Estimation","title":"Generating Observations","text":"# Create observations DataFrame\nobs = generate_observations(seq, stats, sampler)\n\nThe resulting DataFrame contains:\n\nColumn Description\nevent_index Index of the focal event in the sequence\nsender Sender ID\nreceiver Receiver ID\nis_event true for cases, false for controls\nstratum Stratum ID (groups each case with its controls)\n<stat_name> One column per statistic","category":"section"},{"location":"guide/estimation/#Options","page":"Model Estimation","title":"Options","text":"obs = generate_observations(seq, stats, sampler;\n    start_index = 1,           # First event to include\n    end_index = length(seq),   # Last event to include\n    decay = 0.0,               # Exponential decay rate\n    at_risk = nothing          # Custom set of actors at risk\n)","category":"section"},{"location":"guide/estimation/#Excluding-Early-Events","page":"Model Estimation","title":"Excluding Early Events","text":"The first few events may have unreliable statistics (no history):\n\n# Skip first 5 events\nobs = generate_observations(seq, stats, sampler; start_index=6)","category":"section"},{"location":"guide/estimation/#Custom-Risk-Sets","page":"Model Estimation","title":"Custom Risk Sets","text":"Specify a custom set of actors at risk:\n\n# Only actors 1-100 can send/receive\nat_risk = collect(1:100)\nobs = generate_observations(seq, stats, sampler; at_risk=at_risk)","category":"section"},{"location":"guide/estimation/#Fitting-Models","page":"Model Estimation","title":"Fitting Models","text":"","category":"section"},{"location":"guide/estimation/#Direct-Fitting-(Recommended)","page":"Model Estimation","title":"Direct Fitting (Recommended)","text":"The simplest approach combines sampling and fitting:\n\nresult = fit_rem(seq, stats;\n    n_controls = 100,\n    seed = 42\n)","category":"section"},{"location":"guide/estimation/#Two-Stage-Fitting","page":"Model Estimation","title":"Two-Stage Fitting","text":"For more control over the process:\n\n# Stage 1: Generate observations\nsampler = CaseControlSampler(n_controls=100, seed=42)\nobs = generate_observations(seq, stats, sampler)\n\n# Inspect observations if needed\nprintln(\"Observations: \", nrow(obs))\nprintln(\"Cases: \", sum(obs.is_event))\nprintln(\"Controls: \", sum(.!obs.is_event))\n\n# Stage 2: Fit model\nstat_names = [name(s) for s in stats]\nresult = fit_rem(obs, stat_names)","category":"section"},{"location":"guide/estimation/#Fit-Options","page":"Model Estimation","title":"Fit Options","text":"result = fit_rem(obs, stat_names;\n    maxiter = 100,   # Maximum Newton-Raphson iterations\n    tol = 1e-8       # Convergence tolerance for log-likelihood\n)","category":"section"},{"location":"guide/estimation/#Understanding-Results","page":"Model Estimation","title":"Understanding Results","text":"The REMResult object contains:\n\nField Type Description\ncoefficients Vector{Float64} Estimated coefficients\nstd_errors Vector{Float64} Standard errors\nz_values Vector{Float64} Z-statistics (coef/se)\np_values Vector{Float64} Two-sided p-values\nstat_names Vector{String} Names of statistics\nn_events Int Number of events (cases)\nn_observations Int Total observations\nlog_likelihood Float64 Log-likelihood at convergence\nconverged Bool Whether optimization converged","category":"section"},{"location":"guide/estimation/#Accessor-Functions","page":"Model Estimation","title":"Accessor Functions","text":"coef(result)        # Coefficient vector\nstderror(result)    # Standard errors vector\ncoeftable(result)   # Full results as DataFrame","category":"section"},{"location":"guide/estimation/#Displaying-Results","page":"Model Estimation","title":"Displaying Results","text":"println(result)\n\nOutput:\n\nRelational Event Model Results\n==============================\nEvents: 100, Observations: 10100\nLog-likelihood: -234.5678\nConverged: true\n\nCoefficients:\n------------------------------------------------------------\nStatistic                  Coef    Std.Err          z      P>|z|\n------------------------------------------------------------\nrepetition               0.4523     0.0812     5.5700     0.0000 ***\nreciprocity              0.3156     0.0923     3.4200     0.0006 ***\nsender_activity          0.0234     0.0156     1.5000     0.1336\nreceiver_popularity      0.0567     0.0189     3.0000     0.0027 **\n------------------------------------------------------------\nSignif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1","category":"section"},{"location":"guide/estimation/#Interpreting-Coefficients","page":"Model Estimation","title":"Interpreting Coefficients","text":"","category":"section"},{"location":"guide/estimation/#Log-Hazard-Ratios","page":"Model Estimation","title":"Log-Hazard Ratios","text":"Coefficients are log-hazard ratios. A coefficient β means:\n\nexp(β) is the multiplicative effect on the event rate\nβ > 0 increases the rate\nβ < 0 decreases the rate","category":"section"},{"location":"guide/estimation/#Example-Interpretations","page":"Model Estimation","title":"Example Interpretations","text":"Statistic Coefficient exp(β) Interpretation\nRepetition 0.5 1.65 Each past s→r event increases rate by 65%\nReciprocity 0.8 2.23 Past r→s events double the rate\nSenderActivity -0.1 0.90 High-activity senders have 10% lower per-dyad rates\nTransitiveClosure 0.3 1.35 Each shared partner increases rate by 35%\nNodeMatch 0.4 1.49 Same-attribute dyads are 49% more likely","category":"section"},{"location":"guide/estimation/#Confidence-Intervals","page":"Model Estimation","title":"Confidence Intervals","text":"Approximate 95% confidence intervals:\n\nusing Distributions\n\nalpha = 0.05\nz = quantile(Normal(), 1 - alpha/2)\n\nlower = coef(result) .- z .* stderror(result)\nupper = coef(result) .+ z .* stderror(result)\n\n# Hazard ratio confidence intervals\nhr_lower = exp.(lower)\nhr_upper = exp.(upper)","category":"section"},{"location":"guide/estimation/#Computing-Statistics-Without-Sampling","page":"Model Estimation","title":"Computing Statistics Without Sampling","text":"To compute statistics for all events (without controls):\n\nstats_df = compute_statistics(seq, stats; decay=0.0)\n\nReturns a DataFrame with one row per event:\n\nColumn Description\nsender Sender ID\nreceiver Receiver ID\ntime Event time\n<stat_name> Statistic values\n\nUse case: Exploratory analysis, visualization, or exporting statistics.","category":"section"},{"location":"guide/estimation/#Model-Comparison","page":"Model Estimation","title":"Model Comparison","text":"","category":"section"},{"location":"guide/estimation/#Comparing-Log-Likelihoods","page":"Model Estimation","title":"Comparing Log-Likelihoods","text":"# Nested models\nstats1 = [Repetition(), Reciprocity()]\nstats2 = [Repetition(), Reciprocity(), TransitiveClosure()]\n\nresult1 = fit_rem(seq, stats1; n_controls=100, seed=42)\nresult2 = fit_rem(seq, stats2; n_controls=100, seed=42)\n\nprintln(\"Model 1 LL: \", result1.log_likelihood)\nprintln(\"Model 2 LL: \", result2.log_likelihood)\n\n# Likelihood ratio test (approximate)\nusing Distributions\nLR = 2 * (result2.log_likelihood - result1.log_likelihood)\ndf = length(stats2) - length(stats1)\np_value = 1 - cdf(Chisq(df), LR)\nprintln(\"LR test p-value: \", p_value)","category":"section"},{"location":"guide/estimation/#Multiple-Seeds","page":"Model Estimation","title":"Multiple Seeds","text":"For robustness, compare results across different random seeds:\n\nresults = [fit_rem(seq, stats; n_controls=100, seed=s) for s in 1:5]\n\n# Check coefficient stability\nfor (i, r) in enumerate(results)\n    println(\"Seed $i: \", round.(coef(r), digits=3))\nend","category":"section"},{"location":"guide/estimation/#Convergence-Issues","page":"Model Estimation","title":"Convergence Issues","text":"","category":"section"},{"location":"guide/estimation/#Checking-Convergence","page":"Model Estimation","title":"Checking Convergence","text":"if !result.converged\n    @warn \"Model did not converge - results may be unreliable\"\nend","category":"section"},{"location":"guide/estimation/#Common-Causes-and-Solutions","page":"Model Estimation","title":"Common Causes and Solutions","text":"Issue Symptom Solution\nPerfect separation Very large coefficients Remove or transform problematic statistic\nMulticollinearity Large standard errors Remove correlated statistics\nSparse data Non-convergence Increase n_controls, simplify model\nToo many parameters Slow convergence Reduce model complexity","category":"section"},{"location":"guide/estimation/#Handling-Non-Convergence","page":"Model Estimation","title":"Handling Non-Convergence","text":"# Increase iterations\nresult = fit_rem(seq, stats; n_controls=100, maxiter=500)\n\n# Check for separation\nfor (i, name) in enumerate(result.stat_names)\n    if abs(result.coefficients[i]) > 10\n        @warn \"Possible separation for $name\"\n    end\nend","category":"section"},{"location":"guide/estimation/#Advanced-Topics","page":"Model Estimation","title":"Advanced Topics","text":"","category":"section"},{"location":"guide/estimation/#Bootstrapping-Standard-Errors","page":"Model Estimation","title":"Bootstrapping Standard Errors","text":"For more robust standard errors:\n\nfunction bootstrap_rem(seq, stats; n_bootstrap=100, n_controls=100)\n    n = length(seq)\n    boot_coefs = zeros(n_bootstrap, length(stats))\n\n    for b in 1:n_bootstrap\n        # Resample events with replacement\n        indices = rand(1:n, n)\n        boot_events = [seq[i] for i in sort(indices)]\n        boot_seq = EventSequence(boot_events)\n\n        result = fit_rem(boot_seq, stats; n_controls=n_controls, seed=b)\n        boot_coefs[b, :] = coef(result)\n    end\n\n    # Bootstrap standard errors\n    boot_se = vec(std(boot_coefs, dims=1))\n    return boot_se\nend","category":"section"},{"location":"guide/estimation/#Time-Varying-Effects","page":"Model Estimation","title":"Time-Varying Effects","text":"Model effects that change over time using event windows:\n\n# Split sequence into periods\nmid_point = length(seq) ÷ 2\n\n# Fit separate models\nresult_early = fit_rem(seq, stats;\n    n_controls=100, start_index=1, end_index=mid_point)\nresult_late = fit_rem(seq, stats;\n    n_controls=100, start_index=mid_point+1)\n\n# Compare coefficients\nprintln(\"Early period: \", coef(result_early))\nprintln(\"Late period: \", coef(result_late))","category":"section"},{"location":"guide/estimation/#Best-Practices","page":"Model Estimation","title":"Best Practices","text":"Set random seed: Always use a seed for reproducibility\nCheck convergence: Verify result.converged == true\nAdequate controls: Use at least 50-100 controls\nSkip early events: Consider excluding first few events with start_index\nAvoid multicollinearity: Don't include highly correlated statistics\nScale large counts: Use LogDegree for networks with high-degree hubs\nSufficient events: Aim for at least 10 events per parameter\nCompare seeds: Verify stability across different random seeds","category":"section"},{"location":"api/types/#Types-API-Reference","page":"Types","title":"Types API Reference","text":"This page documents the core data types in REM.jl.","category":"section"},{"location":"api/types/#Events","page":"Types","title":"Events","text":"","category":"section"},{"location":"api/types/#Event","page":"Types","title":"Event","text":"","category":"section"},{"location":"api/types/#EventSequence","page":"Types","title":"EventSequence","text":"","category":"section"},{"location":"api/types/#Actor-Data","page":"Types","title":"Actor Data","text":"","category":"section"},{"location":"api/types/#ActorSet","page":"Types","title":"ActorSet","text":"","category":"section"},{"location":"api/types/#NodeAttribute","page":"Types","title":"NodeAttribute","text":"","category":"section"},{"location":"api/types/#RiskSet","page":"Types","title":"RiskSet","text":"","category":"section"},{"location":"api/types/#Network-State","page":"Types","title":"Network State","text":"The NetworkState type maintains the cumulative state of the network as events are processed. It tracks dyad counts, degrees, and neighbor sets, optionally with exponential decay.","category":"section"},{"location":"api/types/#NetworkState","page":"Types","title":"NetworkState","text":"","category":"section"},{"location":"api/types/#State-Updates","page":"Types","title":"State Updates","text":"","category":"section"},{"location":"api/types/#State-Query-Functions","page":"Types","title":"State Query Functions","text":"These functions query the current network state for various quantities.","category":"section"},{"location":"api/types/#Dyad-Queries","page":"Types","title":"Dyad Queries","text":"","category":"section"},{"location":"api/types/#Degree-Queries","page":"Types","title":"Degree Queries","text":"","category":"section"},{"location":"api/types/#Neighbor-Queries","page":"Types","title":"Neighbor Queries","text":"","category":"section"},{"location":"api/types/#Time-Utilities","page":"Types","title":"Time Utilities","text":"","category":"section"},{"location":"api/types/#REM.Event","page":"Types","title":"REM.Event","text":"Event{T}\n\nRepresents a single relational event (directed interaction between actors).\n\nFields\n\nsender::Int: ID of the event sender/source\nreceiver::Int: ID of the event receiver/target\ntime::T: Timestamp of the event\neventtype::Symbol: Type/category of the event (default: :event)\nweight::Float64: Weight/magnitude of the event (default: 1.0)\n\n\n\n\n\n","category":"type"},{"location":"api/types/#REM.EventSequence","page":"Types","title":"REM.EventSequence","text":"EventSequence{T}\n\nA sequence of relational events, sorted by time.\n\nFields\n\nevents::Vector{Event{T}}: Vector of events sorted by time\nactors::Set{Int}: Set of all actor IDs\nn_actors::Int: Number of unique actors\neventtypes::Set{Symbol}: Set of all event types\n\n\n\n\n\n","category":"type"},{"location":"api/types/#REM.ActorSet","page":"Types","title":"REM.ActorSet","text":"ActorSet\n\nRepresents a set of actors with optional ID-to-name mapping.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#REM.NodeAttribute","page":"Types","title":"REM.NodeAttribute","text":"NodeAttribute{T}\n\nStores an attribute value for each actor.\n\nFields\n\nname::Symbol: Name of the attribute\nvalues::Dict{Int, T}: Mapping from actor ID to attribute value\ndefault::T: Default value for actors not in the dict\n\n\n\n\n\n","category":"type"},{"location":"api/types/#REM.RiskSet","page":"Types","title":"REM.RiskSet","text":"RiskSet\n\nRepresents the risk set for a given event - the set of potential dyads that could have experienced an event at a given time.\n\nFields\n\nevent_index::Int: Index of the focal event in the sequence\npotential_senders::Vector{Int}: Actors who could be senders\npotential_receivers::Vector{Int}: Actors who could be receivers\nexclude_self_loops::Bool: Whether to exclude self-loops from risk set\n\n\n\n\n\n","category":"type"},{"location":"api/types/#REM.NetworkState","page":"Types","title":"REM.NetworkState","text":"NetworkState\n\nTracks the cumulative state of the network up to a given point in time. Used for efficient computation of statistics.\n\nFields\n\nn_actors::Int: Number of actors\ndyad_counts::Dict{Tuple{Int,Int}, Float64}: Weighted count of events for each directed dyad\nundirected_counts::Dict{Tuple{Int,Int}, Float64}: Weighted count for undirected dyads (min,max sorted)\nout_degree::Dict{Int, Float64}: Weighted out-degree for each actor\nin_degree::Dict{Int, Float64}: Weighted in-degree for each actor\nlast_event_time::Dict{Tuple{Int,Int}, Any}: Time of last event for each dyad\ndecay::Float64: Exponential decay rate (0 = no decay)\ncurrent_time::Any: Current time in the event sequence\n\n\n\n\n\n","category":"type"},{"location":"api/types/#REM.update!","page":"Types","title":"REM.update!","text":"update!(state::NetworkState, event::Event)\n\nUpdate the network state with a new event.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#REM.reset!","page":"Types","title":"REM.reset!","text":"reset!(state::NetworkState)\n\nReset the network state to empty.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#REM.get_dyad_count","page":"Types","title":"REM.get_dyad_count","text":"get_dyad_count(state::NetworkState, sender::Int, receiver::Int) -> Float64\n\nGet the weighted count of events from sender to receiver.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#REM.get_undirected_count","page":"Types","title":"REM.get_undirected_count","text":"get_undirected_count(state::NetworkState, actor1::Int, actor2::Int) -> Float64\n\nGet the weighted count of events between two actors (in either direction).\n\n\n\n\n\n","category":"function"},{"location":"api/types/#REM.has_edge","page":"Types","title":"REM.has_edge","text":"has_edge(state::NetworkState, sender::Int, receiver::Int) -> Bool\n\nCheck if there has been at least one event from sender to receiver.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#REM.get_out_degree","page":"Types","title":"REM.get_out_degree","text":"get_out_degree(state::NetworkState, actor::Int) -> Float64\n\nGet the weighted out-degree of an actor.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#REM.get_in_degree","page":"Types","title":"REM.get_in_degree","text":"get_in_degree(state::NetworkState, actor::Int) -> Float64\n\nGet the weighted in-degree of an actor.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#REM.get_out_neighbors","page":"Types","title":"REM.get_out_neighbors","text":"get_out_neighbors(state::NetworkState, actor::Int) -> Set{Int}\n\nGet the set of actors to whom the given actor has sent events.\n\n\n\n\n\n","category":"function"},{"location":"api/types/#REM.get_in_neighbors","page":"Types","title":"REM.get_in_neighbors","text":"get_in_neighbors(state::NetworkState, actor::Int) -> Set{Int}\n\nGet the set of actors who have sent events to the given actor.\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This tutorial walks through common use cases for REM.jl, from basic event modeling to advanced analysis.","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"Install REM.jl from GitHub:\n\nusing Pkg\nPkg.add(url=\"https://github.com/simoneSantoni/REM.jl\")","category":"section"},{"location":"getting_started/#Basic-Workflow","page":"Getting Started","title":"Basic Workflow","text":"The typical REM.jl workflow consists of four steps:\n\nLoad or create events - Prepare your relational event data\nDefine statistics - Choose which effects to model\nFit the model - Estimate coefficients via case-control sampling\nInterpret results - Analyze the fitted model","category":"section"},{"location":"getting_started/#Step-1:-Create-an-Event-Sequence","page":"Getting Started","title":"Step 1: Create an Event Sequence","text":"Events represent directed interactions between actors at specific times:\n\nusing REM\n\n# Create individual events: Event(sender, receiver, time)\nevents = [\n    Event(1, 2, 1.0),   # Actor 1 → Actor 2 at time 1.0\n    Event(2, 1, 2.0),   # Actor 2 → Actor 1 at time 2.0\n    Event(1, 3, 3.0),   # Actor 1 → Actor 3 at time 3.0\n    Event(3, 2, 4.0),   # Actor 3 → Actor 2 at time 4.0\n    Event(2, 3, 5.0),   # Actor 2 → Actor 3 at time 5.0\n    Event(1, 2, 6.0),   # Actor 1 → Actor 2 at time 6.0 (repetition)\n]\n\n# Create an EventSequence (automatically sorted by time)\nseq = EventSequence(events)\n\nprintln(\"Number of events: \", length(seq))      # 6\nprintln(\"Number of actors: \", seq.n_actors)     # 3\nprintln(\"Actors: \", seq.actors)                  # Set([1, 2, 3])","category":"section"},{"location":"getting_started/#Loading-from-a-DataFrame","page":"Getting Started","title":"Loading from a DataFrame","text":"More commonly, you'll load events from existing data:\n\nusing DataFrames\n\ndf = DataFrame(\n    sender = [1, 2, 1, 3, 2, 1],\n    receiver = [2, 1, 3, 2, 3, 2],\n    time = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n)\n\nseq = load_events(df)","category":"section"},{"location":"getting_started/#Loading-from-CSV","page":"Getting Started","title":"Loading from CSV","text":"seq = load_events(\"path/to/events.csv\")","category":"section"},{"location":"getting_started/#String-Actor-Names","page":"Getting Started","title":"String Actor Names","text":"When actors are identified by names:\n\ndf = DataFrame(\n    sender = [\"Alice\", \"Bob\", \"Alice\"],\n    receiver = [\"Bob\", \"Alice\", \"Carol\"],\n    time = [1.0, 2.0, 3.0]\n)\n\nseq = load_events(df; actor_names=true)\n# Actors are assigned numeric IDs internally","category":"section"},{"location":"getting_started/#Step-2:-Define-Statistics","page":"Getting Started","title":"Step 2: Define Statistics","text":"Statistics capture different mechanisms that might drive event occurrence:\n\n# Basic dyadic and degree statistics\nstats = [\n    Repetition(),           # Past events from sender to receiver\n    Reciprocity(),          # Past events from receiver to sender\n    SenderActivity(),       # Sender's overall activity (out-degree)\n    ReceiverPopularity(),   # Receiver's overall popularity (in-degree)\n]","category":"section"},{"location":"getting_started/#Exploring-Available-Statistics","page":"Getting Started","title":"Exploring Available Statistics","text":"REM.jl provides many statistics organized by type:\n\nCategory Statistics Description\nDyad Repetition, Reciprocity, InertiaStatistic, RecencyStatistic History between focal dyad\nDegree SenderActivity, ReceiverPopularity, TotalDegree, LogDegree Actor activity/popularity\nTriangle TransitiveClosure, CyclicClosure, SharedSender, SharedReceiver Triadic closure patterns\nFour-Cycle FourCycle, GeometricWeightedFourCycles Local clustering effects\nNode Attribute NodeMatch, NodeMix, NodeDifference, SenderAttribute Homophily and covariate effects","category":"section"},{"location":"getting_started/#Example:-Comprehensive-Model","page":"Getting Started","title":"Example: Comprehensive Model","text":"# Create node attributes\ngender = NodeAttribute(:gender, Dict(1=>\"M\", 2=>\"F\", 3=>\"M\"), \"Unknown\")\n\n# Build a comprehensive model\nstats = [\n    # Dyadic effects\n    Repetition(),\n    Reciprocity(),\n\n    # Actor effects\n    SenderActivity(),\n    ReceiverPopularity(),\n\n    # Structural effects\n    TransitiveClosure(),\n    CyclicClosure(),\n\n    # Attribute effects\n    NodeMatch(gender),\n]","category":"section"},{"location":"getting_started/#Step-3:-Fit-the-Model","page":"Getting Started","title":"Step 3: Fit the Model","text":"Use fit_rem to estimate the model:\n\nresult = fit_rem(seq, stats; n_controls=100, seed=42)","category":"section"},{"location":"getting_started/#Key-Parameters","page":"Getting Started","title":"Key Parameters","text":"Parameter Description Typical Value\nn_controls Control samples per event 50-200\nseed Random seed for reproducibility Any integer\ndecay Exponential decay rate 0.0 (no decay)\nexclude_self_loops Exclude self-events from risk set true","category":"section"},{"location":"getting_started/#Choosing-Number-of-Controls","page":"Getting Started","title":"Choosing Number of Controls","text":"More controls provide more accurate estimates but increase computation:\n\n# Quick exploratory analysis\nresult_quick = fit_rem(seq, stats; n_controls=50, seed=42)\n\n# Final analysis\nresult_final = fit_rem(seq, stats; n_controls=200, seed=42)","category":"section"},{"location":"getting_started/#Step-4:-Interpret-Results","page":"Getting Started","title":"Step 4: Interpret Results","text":"The result object contains coefficient estimates and test statistics:\n\n# Print formatted summary table\nprintln(result)\n\n# Output:\n# Relational Event Model Results\n# ==============================\n# Events: 6, Observations: 606\n# Log-likelihood: -12.3456\n# Converged: true\n#\n# Coefficients:\n# ------------------------------------------------------------\n# Statistic                  Coef    Std.Err          z      P>|z|\n# ------------------------------------------------------------\n# repetition               0.4523     0.0812     5.5700     0.0000 ***\n# reciprocity              0.3156     0.0923     3.4200     0.0006 ***\n# ...","category":"section"},{"location":"getting_started/#Accessing-Results-Programmatically","page":"Getting Started","title":"Accessing Results Programmatically","text":"# Coefficient vector\ncoef(result)\n\n# Standard errors\nstderror(result)\n\n# Full table as DataFrame\ndf = coeftable(result)","category":"section"},{"location":"getting_started/#Interpreting-Coefficients","page":"Getting Started","title":"Interpreting Coefficients","text":"Coefficients are log-hazard ratios:\n\nCoefficient Interpretation\nβ > 0 Statistic increases event rate\nβ < 0 Statistic decreases event rate\nβ = 0 No effect\nexp(β) Multiplicative effect on rate\n\nExample interpretations:\n\nrepetition = 0.5 → Each past s→r event increases rate by 65% (exp(0.5) ≈ 1.65)\nreciprocity = 0.8 → Events are 2.2× more likely when r→s has occurred (exp(0.8) ≈ 2.23)\nsender_activity = -0.1 → High-activity senders have slightly lower per-dyad rates","category":"section"},{"location":"getting_started/#Complete-Example","page":"Getting Started","title":"Complete Example","text":"using REM\nusing DataFrames\n\n# Create event data with clear patterns\nevents = [\n    # Initial interactions\n    Event(1, 2, 1.0),\n    Event(2, 3, 2.0),\n\n    # Reciprocity: 2→1 after 1→2\n    Event(2, 1, 3.0),\n\n    # Transitive closure: 1→3 after 1→2 and 2→3\n    Event(1, 3, 4.0),\n\n    # Repetition: 1→2 again\n    Event(1, 2, 5.0),\n\n    # More activity\n    Event(3, 1, 6.0),\n    Event(2, 1, 7.0),\n    Event(1, 3, 8.0),\n]\nseq = EventSequence(events)\n\n# Define model with structural effects\nstats = [\n    Repetition(),\n    Reciprocity(),\n    SenderActivity(),\n    ReceiverPopularity(),\n    TransitiveClosure(),\n]\n\n# Fit with case-control sampling\nresult = fit_rem(seq, stats; n_controls=50, seed=123)\n\n# View results\nprintln(result)\n\n# Get coefficient table\ndf = coeftable(result)\nprintln(\"\\nCoefficient Table:\")\nprintln(df)\n\n# Check model convergence\nif result.converged\n    println(\"\\nModel converged successfully\")\n    println(\"Log-likelihood: \", result.log_likelihood)\nelse\n    println(\"\\nWarning: Model did not converge\")\nend","category":"section"},{"location":"getting_started/#Working-with-Temporal-Decay","page":"Getting Started","title":"Working with Temporal Decay","text":"For time-sensitive effects where older events matter less:\n\n# Set halflife: events lose half their weight after 10 time units\ndecay = halflife_to_decay(10.0)\n\nresult = fit_rem(seq, stats;\n    n_controls = 100,\n    decay = decay,\n    seed = 42\n)\n\nSee Temporal Decay for more details.","category":"section"},{"location":"getting_started/#Comparing-Models","page":"Getting Started","title":"Comparing Models","text":"# Model 1: Basic effects\nstats1 = [Repetition(), Reciprocity()]\n\n# Model 2: Add structural effects\nstats2 = [Repetition(), Reciprocity(), TransitiveClosure(), CyclicClosure()]\n\nresult1 = fit_rem(seq, stats1; n_controls=100, seed=42)\nresult2 = fit_rem(seq, stats2; n_controls=100, seed=42)\n\n# Compare log-likelihoods\nprintln(\"Model 1 LL: \", result1.log_likelihood)\nprintln(\"Model 2 LL: \", result2.log_likelihood)\n\n# Higher log-likelihood (less negative) indicates better fit\nif result2.log_likelihood > result1.log_likelihood\n    println(\"Model 2 fits better\")\nend","category":"section"},{"location":"getting_started/#Best-Practices","page":"Getting Started","title":"Best Practices","text":"Start simple: Begin with basic dyadic effects before adding structural terms\nCheck convergence: Always verify result.converged == true\nUse adequate controls: At least 50-100 controls per case\nSet random seed: For reproducibility across runs\nScale appropriately: For large networks, use log-transformed degree statistics\nSufficient events: Rule of thumb - at least 10 events per parameter","category":"section"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Learn about Events and Data for data handling\nExplore all Statistics available\nUnderstand Model Estimation in detail\nUse Temporal Decay for time-weighted effects","category":"section"},{"location":"api/estimation/#Estimation-API-Reference","page":"Estimation","title":"Estimation API Reference","text":"This page documents the functions for data loading, observation generation, and model fitting.","category":"section"},{"location":"api/estimation/#Data-Loading","page":"Estimation","title":"Data Loading","text":"","category":"section"},{"location":"api/estimation/#load_events","page":"Estimation","title":"load_events","text":"","category":"section"},{"location":"api/estimation/#Observation-Generation","page":"Estimation","title":"Observation Generation","text":"","category":"section"},{"location":"api/estimation/#CaseControlSampler","page":"Estimation","title":"CaseControlSampler","text":"","category":"section"},{"location":"api/estimation/#generate_observations","page":"Estimation","title":"generate_observations","text":"","category":"section"},{"location":"api/estimation/#compute_statistics","page":"Estimation","title":"compute_statistics","text":"","category":"section"},{"location":"api/estimation/#Model-Fitting","page":"Estimation","title":"Model Fitting","text":"","category":"section"},{"location":"api/estimation/#fit_rem","page":"Estimation","title":"fit_rem","text":"","category":"section"},{"location":"api/estimation/#REMResult","page":"Estimation","title":"REMResult","text":"","category":"section"},{"location":"api/estimation/#Result-Accessors","page":"Estimation","title":"Result Accessors","text":"","category":"section"},{"location":"api/estimation/#Utility-Functions","page":"Estimation","title":"Utility Functions","text":"","category":"section"},{"location":"api/estimation/#Time-Decay","page":"Estimation","title":"Time Decay","text":"","category":"section"},{"location":"api/estimation/#Risk-Set-Utilities","page":"Estimation","title":"Risk Set Utilities","text":"","category":"section"},{"location":"api/estimation/#REM.load_events","page":"Estimation","title":"REM.load_events","text":"load_events(filepath::String; kwargs...) -> EventSequence\n\nLoad events from a CSV file.\n\nArguments\n\nfilepath: Path to the CSV file\n\nKeyword Arguments\n\nsender_col::Symbol=:sender: Column name for sender IDs\nreceiver_col::Symbol=:receiver: Column name for receiver IDs\ntime_col::Symbol=:time: Column name for timestamps\ntype_col::Union{Symbol,Nothing}=nothing: Column name for event types\nweight_col::Union{Symbol,Nothing}=nothing: Column name for event weights\ntime_type::Type=Float64: Type to parse timestamps as\nactor_names::Bool=false: If true, treat sender/receiver as names and assign numeric IDs\n\nReturns\n\nEventSequence: Sequence of loaded events\n\n\n\n\n\nload_events(df::DataFrame; kwargs...) -> EventSequence\n\nLoad events from a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.CaseControlSampler","page":"Estimation","title":"REM.CaseControlSampler","text":"CaseControlSampler\n\nGenerates observations using case-control sampling. For each observed event (case), samples a specified number of non-events (controls) from the risk set.\n\nFields\n\nn_controls::Int: Number of control samples per case\nexclude_self_loops::Bool: Whether to exclude self-loops from sampling\nseed::Union{Int, Nothing}: Random seed for reproducibility\n\n\n\n\n\n","category":"type"},{"location":"api/estimation/#REM.generate_observations","page":"Estimation","title":"REM.generate_observations","text":"generate_observations(seq::EventSequence, stats::Vector{<:AbstractStatistic},\n                      sampler::CaseControlSampler; kwargs...) -> DataFrame\n\nGenerate observations for model estimation using case-control sampling.\n\nArguments\n\nseq::EventSequence: The event sequence to analyze\nstats::Vector{<:AbstractStatistic}: Statistics to compute\nsampler::CaseControlSampler: Sampling configuration\n\nKeyword Arguments\n\nstart_index::Int=1: Index of first event to include\nend_index::Int=length(seq): Index of last event to include\ndecay::Float64=0.0: Exponential decay rate for network state\nat_risk::Union{Nothing, Set{Int}}=nothing: Set of actors \"at risk\" (if nothing, all actors)\n\nReturns\n\nDataFrame: Observations with columns for each statistic, plus is_event and stratum\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.compute_statistics","page":"Estimation","title":"REM.compute_statistics","text":"compute_statistics(seq::EventSequence, stats::Vector{<:AbstractStatistic};\n                   decay::Float64=0.0) -> DataFrame\n\nCompute statistics for all events in a sequence (without sampling controls).\n\nReturns\n\nDataFrame: One row per event with computed statistics\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.fit_rem","page":"Estimation","title":"REM.fit_rem","text":"fit_rem(observations::DataFrame, stat_names::Vector{String}; kwargs...) -> REMResult\n\nFit a relational event model using stratified Cox regression.\n\nArguments\n\nobservations::DataFrame: Output from generate_observations\nstat_names::Vector{String}: Names of statistic columns to include in the model\n\nKeyword Arguments\n\nmaxiter::Int=100: Maximum iterations for optimization\ntol::Float64=1e-8: Convergence tolerance\n\nReturns\n\nREMResult: Fitted model results\n\n\n\n\n\nfit_rem(seq::EventSequence, stats::Vector{<:AbstractStatistic}; kwargs...) -> REMResult\n\nFit a relational event model directly from an event sequence.\n\nArguments\n\nseq::EventSequence: The event sequence\nstats::Vector{<:AbstractStatistic}: Statistics to include in the model\n\nKeyword Arguments\n\nn_controls::Int=100: Number of controls per case\ndecay::Float64=0.0: Exponential decay rate\nexclude_self_loops::Bool=true: Exclude self-loops from risk set\nseed::Union{Int,Nothing}=nothing: Random seed\nmaxiter::Int=100: Maximum iterations\ntol::Float64=1e-8: Convergence tolerance\n\nReturns\n\nREMResult: Fitted model results\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.REMResult","page":"Estimation","title":"REM.REMResult","text":"REMResult\n\nResults from fitting a relational event model.\n\nFields\n\ncoefficients::Vector{Float64}: Estimated coefficients\nstd_errors::Vector{Float64}: Standard errors of coefficients\nz_values::Vector{Float64}: Z-statistics\np_values::Vector{Float64}: P-values (two-sided)\nstat_names::Vector{String}: Names of statistics\nn_events::Int: Number of events in the model\nn_observations::Int: Total number of observations\nlog_likelihood::Float64: Log-likelihood at convergence\nconverged::Bool: Whether the optimization converged\n\n\n\n\n\n","category":"type"},{"location":"api/estimation/#REM.coef","page":"Estimation","title":"REM.coef","text":"coef(result::REMResult) -> Vector{Float64}\n\nExtract coefficients from a fitted model.\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.stderror","page":"Estimation","title":"REM.stderror","text":"stderror(result::REMResult) -> Vector{Float64}\n\nExtract standard errors from a fitted model.\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.coeftable","page":"Estimation","title":"REM.coeftable","text":"coeftable(result::REMResult) -> DataFrame\n\nReturn coefficients as a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.halflife_to_decay","page":"Estimation","title":"REM.halflife_to_decay","text":"halflife_to_decay(halflife::Real) -> Float64\n\nConvert a halflife parameter to an exponential decay rate. The decay rate λ is such that weight = exp(-λ * elapsed_time). At time = halflife, the weight is 0.5.\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.decay_to_halflife","page":"Estimation","title":"REM.decay_to_halflife","text":"decay_to_halflife(decay::Real) -> Float64\n\nConvert an exponential decay rate to a halflife parameter.\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#REM.compute_decay_weight","page":"Estimation","title":"REM.compute_decay_weight","text":"compute_decay_weight(elapsed_time::Real, decay::Real) -> Float64\n\nCompute the exponential decay weight for a given elapsed time.\n\n\n\n\n\n","category":"function"},{"location":"guide/decay/#Temporal-Decay","page":"Temporal Decay","title":"Temporal Decay","text":"REM.jl supports exponential decay of network effects, allowing past events to have diminishing influence over time. This captures the intuition that recent interactions are more relevant than older ones.","category":"section"},{"location":"guide/decay/#Why-Use-Decay?","page":"Temporal Decay","title":"Why Use Decay?","text":"In many applications, recent events are more relevant than older ones:\n\nA communication last week matters more than one from a year ago\nRelationships may weaken without recent interaction\nNetwork effects fade over time\nMemory and attention are finite\n\nTemporal decay captures this by down-weighting older events when computing statistics.","category":"section"},{"location":"guide/decay/#The-Exponential-Decay-Model","page":"Temporal Decay","title":"The Exponential Decay Model","text":"The weight of an event decays exponentially with elapsed time:\n\nw(t) = exp(-lambda cdot Delta t)\n\nWhere:\n\nlambda\nis the decay rate (larger = faster decay)\nDelta t\nis the elapsed time since the event\nAt Delta t = 0: weight = 1.0 (full weight)\nAt \\Delta t = $ halflife: weight = 0.5","category":"section"},{"location":"guide/decay/#Setting-the-Decay-Rate","page":"Temporal Decay","title":"Setting the Decay Rate","text":"","category":"section"},{"location":"guide/decay/#Using-Halflife-(Recommended)","page":"Temporal Decay","title":"Using Halflife (Recommended)","text":"The most intuitive approach is to specify a halflife - the time after which an event has half its original weight:\n\n# Events lose half their weight after 10 time units\ndecay = halflife_to_decay(10.0)","category":"section"},{"location":"guide/decay/#Direct-Decay-Rate","page":"Temporal Decay","title":"Direct Decay Rate","text":"Alternatively, specify the decay rate directly:\n\n# Decay rate of 0.1 per time unit\ndecay = 0.1","category":"section"},{"location":"guide/decay/#Converting-Between-Forms","page":"Temporal Decay","title":"Converting Between Forms","text":"# Halflife to decay rate\ndecay = halflife_to_decay(halflife)\n\n# Decay rate to halflife\nhalflife = decay_to_halflife(decay)\n\n# Relationship: decay = log(2) / halflife","category":"section"},{"location":"guide/decay/#Using-Decay-in-Models","page":"Temporal Decay","title":"Using Decay in Models","text":"","category":"section"},{"location":"guide/decay/#With-fit_rem","page":"Temporal Decay","title":"With fit_rem","text":"result = fit_rem(seq, stats;\n    n_controls = 100,\n    decay = halflife_to_decay(10.0),\n    seed = 42\n)","category":"section"},{"location":"guide/decay/#With-NetworkState","page":"Temporal Decay","title":"With NetworkState","text":"# Create state with decay\nstate = NetworkState(seq; decay=halflife_to_decay(10.0))\n\n# Process events - decay is applied automatically as time advances\nfor event in seq\n    update!(state, event)\nend","category":"section"},{"location":"guide/decay/#With-generate_observations","page":"Temporal Decay","title":"With generate_observations","text":"sampler = CaseControlSampler(n_controls=100, seed=42)\nobs = generate_observations(seq, stats, sampler;\n    decay = halflife_to_decay(10.0)\n)","category":"section"},{"location":"guide/decay/#Decay-with-Different-Time-Types","page":"Temporal Decay","title":"Decay with Different Time Types","text":"","category":"section"},{"location":"guide/decay/#Numeric-Timestamps","page":"Temporal Decay","title":"Numeric Timestamps","text":"For numeric timestamps, decay is applied directly in the same units:\n\n# If time is in hours\nevents = [\n    Event(1, 2, 0.0),   # Hour 0\n    Event(2, 1, 24.0),  # Hour 24 (1 day later)\n]\nseq = EventSequence(events)\n\n# Halflife of 24 hours = one day decay\ndecay = halflife_to_decay(24.0)\nstate = NetworkState(seq; decay=decay)","category":"section"},{"location":"guide/decay/#DateTime-Timestamps","page":"Temporal Decay","title":"DateTime Timestamps","text":"For DateTime, time differences are converted to seconds internally:\n\nusing Dates\n\nevents = [\n    Event(1, 2, DateTime(2024, 1, 1, 10, 0)),  # 10:00 AM\n    Event(2, 1, DateTime(2024, 1, 1, 11, 0)),  # 11:00 AM (1 hour later)\n]\nseq = EventSequence(events)\n\n# Halflife of 1 hour = 3600 seconds\ndecay = halflife_to_decay(3600.0)\nstate = NetworkState(seq; decay=decay)","category":"section"},{"location":"guide/decay/#Date-Timestamps","page":"Temporal Decay","title":"Date Timestamps","text":"For Date, differences are converted to days, then to seconds:\n\nusing Dates\n\nevents = [\n    Event(1, 2, Date(2024, 1, 1)),   # Day 1\n    Event(2, 1, Date(2024, 1, 8)),   # Day 8 (one week later)\n]\nseq = EventSequence(events)\n\n# Halflife of 7 days = 7 * 86400 seconds\ndecay = halflife_to_decay(7.0 * 86400)\nstate = NetworkState(seq; decay=decay)","category":"section"},{"location":"guide/decay/#How-Decay-Affects-Statistics","page":"Temporal Decay","title":"How Decay Affects Statistics","text":"","category":"section"},{"location":"guide/decay/#Dyad-Counts","page":"Temporal Decay","title":"Dyad Counts","text":"Without decay:\n\nget_dyad_count(state, s, r)  # = total number of s→r events\n\nWith decay:\n\nget_dyad_count(state, s, r)  # = Σ exp(-λ × elapsed_time_i)","category":"section"},{"location":"guide/decay/#Example","page":"Temporal Decay","title":"Example","text":"using REM\n\nevents = [\n    Event(1, 2, 0.0),   # First event at t=0\n    Event(1, 2, 10.0),  # Second event at t=10\n]\nseq = EventSequence(events)\n\n# Halflife of 10 time units\ndecay = halflife_to_decay(10.0)\nstate = NetworkState(seq; decay=decay)\n\n# After first event\nupdate!(state, seq[1])\nprintln(get_dyad_count(state, 1, 2))  # 1.0\n\n# After second event\n# First event has decayed: 10 time units = 1 halflife → weight = 0.5\n# Second event is fresh: weight = 1.0\nupdate!(state, seq[2])\nprintln(get_dyad_count(state, 1, 2))  # 1.5 (0.5 + 1.0)","category":"section"},{"location":"guide/decay/#Degrees","page":"Temporal Decay","title":"Degrees","text":"Out-degree and in-degree are similarly weighted:\n\n# Without decay: count of events sent\n# With decay: Σ exp(-λ × elapsed) × event_weight\nget_out_degree(state, actor)\nget_in_degree(state, actor)","category":"section"},{"location":"guide/decay/#All-Statistics","page":"Temporal Decay","title":"All Statistics","text":"Decay affects all statistics that depend on counts:\n\nStatistic Effect of Decay\nRepetition Weighted count of past s→r events\nReciprocity Weighted count of past r→s events\nSenderActivity Weighted out-degree\nReceiverPopularity Weighted in-degree\nTransitiveClosure Weighted count of two-paths\netc. All use weighted counts","category":"section"},{"location":"guide/decay/#Choosing-the-Right-Halflife","page":"Temporal Decay","title":"Choosing the Right Halflife","text":"","category":"section"},{"location":"guide/decay/#Domain-Guidelines","page":"Temporal Decay","title":"Domain Guidelines","text":"The appropriate halflife depends on your domain:\n\nDomain Typical Halflife\nReal-time chat Minutes to hours\nEmail communication Hours to days\nSocial media Days to weeks\nBusiness relationships Weeks to months\nOrganizational ties Months to years\nStable institutions Years","category":"section"},{"location":"guide/decay/#Practical-Guidelines","page":"Temporal Decay","title":"Practical Guidelines","text":"Domain knowledge: What timeframe makes interactions \"stale\"?\nEvent frequency: Halflife should be comparable to typical inter-event times\nObservation period: Halflife should be much smaller than total observation time\nSensitivity analysis: Try different values and compare results","category":"section"},{"location":"guide/decay/#Sensitivity-Analysis","page":"Temporal Decay","title":"Sensitivity Analysis","text":"halflifes = [1.0, 5.0, 10.0, 50.0, 100.0]\nresults = Dict()\n\nfor hl in halflifes\n    decay = halflife_to_decay(hl)\n    result = fit_rem(seq, stats; n_controls=100, decay=decay, seed=42)\n    results[hl] = coef(result)\n    println(\"Halflife $hl: \", round.(coef(result), digits=3))\nend","category":"section"},{"location":"guide/decay/#Recency-Statistic-vs-Global-Decay","page":"Temporal Decay","title":"Recency Statistic vs Global Decay","text":"There are two ways to model time effects:","category":"section"},{"location":"guide/decay/#Global-Decay","page":"Temporal Decay","title":"Global Decay","text":"Affects all statistics through NetworkState:\n\n# All statistics use decayed counts\nresult = fit_rem(seq, stats; decay=halflife_to_decay(10.0))","category":"section"},{"location":"guide/decay/#RecencyStatistic","page":"Temporal Decay","title":"RecencyStatistic","text":"A specific statistic measuring time since last dyad event:\n\nRecencyStatistic(transform=:inverse)     # 1/elapsed\nRecencyStatistic(transform=:log)         # 1/log(1+elapsed)\nRecencyStatistic(transform=:exp_decay, decay=0.1)  # exp(-0.1*elapsed)","category":"section"},{"location":"guide/decay/#Key-Differences","page":"Temporal Decay","title":"Key Differences","text":"Aspect Global Decay RecencyStatistic\nAffects All statistics Only recency\nMeasures Weighted history Time to last event\nParameters Decay rate Transform type\nUse case General fading Dyad-specific timing","category":"section"},{"location":"guide/decay/#Combining-Both","page":"Temporal Decay","title":"Combining Both","text":"You can use both simultaneously:\n\nstats = [\n    Repetition(),           # Affected by global decay\n    Reciprocity(),          # Affected by global decay\n    RecencyStatistic(),     # Additional dyad-specific recency\n    SenderActivity(),       # Affected by global decay\n]\n\nresult = fit_rem(seq, stats;\n    n_controls = 100,\n    decay = halflife_to_decay(10.0),  # Global decay\n    seed = 42\n)\n\nThis allows modeling:\n\nGeneral decay of all network effects (via global decay)\nSpecific recency effects for focal dyads (via RecencyStatistic)","category":"section"},{"location":"guide/decay/#No-Decay-(Default)","page":"Temporal Decay","title":"No Decay (Default)","text":"When decay = 0.0 (the default), all past events have equal weight:\n\n# These are equivalent\nresult = fit_rem(seq, stats; n_controls=100)\nresult = fit_rem(seq, stats; n_controls=100, decay=0.0)\n\nThis is appropriate when:\n\nAll historical interactions are equally relevant\nThe observation period is short\nYou want to maximize statistical power","category":"section"},{"location":"guide/decay/#Example:-Email-Network","page":"Temporal Decay","title":"Example: Email Network","text":"using REM\nusing Dates\n\n# Load email data with DateTime timestamps\nevents = [\n    Event(1, 2, DateTime(2024, 1, 1, 9, 0)),\n    Event(2, 1, DateTime(2024, 1, 1, 9, 30)),\n    Event(1, 3, DateTime(2024, 1, 1, 14, 0)),\n    # ... more events\n]\nseq = EventSequence(events)\n\n# Define statistics\nstats = [\n    Repetition(),\n    Reciprocity(),\n    SenderActivity(),\n    ReceiverPopularity(),\n    TransitiveClosure(),\n]\n\n# Model with 1-week halflife (in seconds)\none_week_seconds = 7 * 24 * 60 * 60\ndecay = halflife_to_decay(Float64(one_week_seconds))\n\nresult = fit_rem(seq, stats;\n    n_controls = 100,\n    decay = decay,\n    seed = 42\n)\n\nprintln(result)","category":"section"},{"location":"guide/decay/#Computational-Notes","page":"Temporal Decay","title":"Computational Notes","text":"Decay is applied incrementally as update! is called\nTime differences are computed relative to state.current_time\nVery fast decay (small halflife) may reduce effective sample size\nVery slow decay (large halflife) approaches no-decay case","category":"section"},{"location":"guide/events/#Events-and-Data","page":"Events and Data","title":"Events and Data","text":"This guide covers how to work with relational event data in REM.jl.","category":"section"},{"location":"guide/events/#Events","page":"Events and Data","title":"Events","text":"An Event represents a single directed interaction between actors:\n\nusing REM\n\n# Basic event: sender, receiver, time\ne = Event(1, 2, 1.0)\n\n# With optional event type and weight\ne = Event(1, 2, 1.0; eventtype=:email, weight=2.0)","category":"section"},{"location":"guide/events/#Event-Fields","page":"Events and Data","title":"Event Fields","text":"Field Type Description Default\nsender Int ID of the event sender Required\nreceiver Int ID of the event receiver Required\ntime T Timestamp of the event Required\neventtype Symbol Category of the event :event\nweight Float64 Weight/magnitude 1.0","category":"section"},{"location":"guide/events/#Accessing-Event-Data","page":"Events and Data","title":"Accessing Event Data","text":"e = Event(1, 2, 3.5; eventtype=:phone, weight=2.0)\n\ne.sender      # 1\ne.receiver    # 2\ne.time        # 3.5\ne.eventtype   # :phone\ne.weight      # 2.0","category":"section"},{"location":"guide/events/#Timestamp-Types","page":"Events and Data","title":"Timestamp Types","text":"REM.jl supports various timestamp types:\n\nusing Dates\n\n# Numeric timestamps\nEvent(1, 2, 1.0)                              # Float64\nEvent(1, 2, 1)                                # Int\n\n# Calendar timestamps\nEvent(1, 2, DateTime(2024, 1, 15, 10, 30))    # DateTime\nEvent(1, 2, Date(2024, 1, 15))                # Date\n\nAll events in a sequence must have the same timestamp type.","category":"section"},{"location":"guide/events/#Event-Sequences","page":"Events and Data","title":"Event Sequences","text":"An EventSequence is a time-sorted collection of events:\n\nevents = [\n    Event(1, 2, 3.0),  # Not in chronological order...\n    Event(2, 1, 1.0),\n    Event(1, 3, 2.0),\n]\nseq = EventSequence(events)  # Automatically sorted by time\n\n# After sorting: times are [1.0, 2.0, 3.0]","category":"section"},{"location":"guide/events/#Accessing-Sequence-Data","page":"Events and Data","title":"Accessing Sequence Data","text":"# Basic access\nseq[1]              # First event (earliest time)\nseq[end]            # Last event (latest time)\nlength(seq)         # Number of events\n\n# Metadata\nseq.n_actors        # Number of unique actors\nseq.actors          # Set of actor IDs\nseq.eventtypes      # Set of event types\n\n# Iteration\nfor event in seq\n    println(event.sender, \" → \", event.receiver)\nend\n\n# Collect times\ntimes = [e.time for e in seq]","category":"section"},{"location":"guide/events/#Adding-Events","page":"Events and Data","title":"Adding Events","text":"Events are inserted maintaining time order:\n\n# Insert a new event\npush!(seq, Event(3, 1, 1.5))\n\n# The sequence remains sorted by time","category":"section"},{"location":"guide/events/#Creating-Empty-Sequences","page":"Events and Data","title":"Creating Empty Sequences","text":"# Empty sequence for Float64 timestamps\nseq = EventSequence{Float64}()\n\n# Add events incrementally\npush!(seq, Event(1, 2, 1.0))\npush!(seq, Event(2, 1, 2.0))","category":"section"},{"location":"guide/events/#Loading-Data","page":"Events and Data","title":"Loading Data","text":"","category":"section"},{"location":"guide/events/#From-DataFrame","page":"Events and Data","title":"From DataFrame","text":"The most common way to load events:\n\nusing DataFrames\n\ndf = DataFrame(\n    sender = [1, 2, 1],\n    receiver = [2, 1, 3],\n    time = [1.0, 2.0, 3.0]\n)\n\nseq = load_events(df)","category":"section"},{"location":"guide/events/#Custom-Column-Names","page":"Events and Data","title":"Custom Column Names","text":"When your DataFrame has different column names:\n\ndf = DataFrame(\n    from = [1, 2, 1],\n    to = [2, 1, 3],\n    timestamp = [1.0, 2.0, 3.0],\n    type = [:email, :email, :meeting],\n    importance = [1.0, 2.0, 1.5]\n)\n\nseq = load_events(df;\n    sender_col = :from,\n    receiver_col = :to,\n    time_col = :timestamp,\n    type_col = :type,\n    weight_col = :importance\n)","category":"section"},{"location":"guide/events/#String-Actor-Names","page":"Events and Data","title":"String Actor Names","text":"When actors are identified by names rather than numeric IDs:\n\ndf = DataFrame(\n    sender = [\"Alice\", \"Bob\", \"Alice\", \"Carol\"],\n    receiver = [\"Bob\", \"Alice\", \"Carol\", \"Bob\"],\n    time = [1.0, 2.0, 3.0, 4.0]\n)\n\nseq = load_events(df; actor_names=true)\n\n# Actors are assigned numeric IDs internally\n# Access the mapping through the returned sequence\nprintln(seq.n_actors)  # 3","category":"section"},{"location":"guide/events/#From-CSV-File","page":"Events and Data","title":"From CSV File","text":"Load directly from a CSV file:\n\n# Basic usage\nseq = load_events(\"events.csv\")\n\n# With options\nseq = load_events(\"events.csv\";\n    sender_col = :source,\n    receiver_col = :target,\n    time_col = :timestamp,\n    actor_names = true\n)","category":"section"},{"location":"guide/events/#DateTime-Parsing","page":"Events and Data","title":"DateTime Parsing","text":"For string timestamps that need parsing:\n\ndf = DataFrame(\n    sender = [1, 2, 1],\n    receiver = [2, 1, 3],\n    time = [\"2024-01-01T10:00:00\", \"2024-01-01T11:00:00\", \"2024-01-01T12:00:00\"]\n)\n\nseq = load_events(df; time_type=DateTime)","category":"section"},{"location":"guide/events/#Node-Attributes","page":"Events and Data","title":"Node Attributes","text":"Node attributes store actor-level covariates for use with attribute statistics.","category":"section"},{"location":"guide/events/#Creating-Attributes","page":"Events and Data","title":"Creating Attributes","text":"# Categorical attribute with default value\ngender = NodeAttribute(:gender,\n    Dict(1 => \"M\", 2 => \"F\", 3 => \"M\"),  # Actor ID → value\n    \"Unknown\"                             # Default for unspecified actors\n)\n\n# Numeric attribute\nage = NodeAttribute(:age,\n    Dict(1 => 25.0, 2 => 30.0, 3 => 28.0),\n    0.0  # Default\n)\n\n# Boolean attribute\nis_manager = NodeAttribute(:manager,\n    Dict(1 => true, 2 => false, 3 => true),\n    false\n)","category":"section"},{"location":"guide/events/#Accessing-Attribute-Values","page":"Events and Data","title":"Accessing Attribute Values","text":"gender[1]  # \"M\"\ngender[2]  # \"F\"\ngender[4]  # \"Unknown\" (default - actor 4 not in dict)\n\nage[1]     # 25.0\nage[99]    # 0.0 (default)","category":"section"},{"location":"guide/events/#Modifying-Attributes","page":"Events and Data","title":"Modifying Attributes","text":"# Set a value\nage[4] = 35.0\n\n# Update existing\nage[1] = 26.0","category":"section"},{"location":"guide/events/#Using-Attributes-in-Statistics","page":"Events and Data","title":"Using Attributes in Statistics","text":"# Homophily: same gender\nNodeMatch(gender)\n\n# Difference: age difference\nNodeDifference(age)\n\n# Main effects\nSenderAttribute(age)\nReceiverAttribute(age)\n\n# Specific combinations\nNodeMix(gender, \"M\", \"F\")  # Male sender, female receiver","category":"section"},{"location":"guide/events/#Actor-Sets","page":"Events and Data","title":"Actor Sets","text":"For specifying custom sets of actors:\n\n# From numeric IDs\nactors = ActorSet([1, 2, 3, 4, 5])\n\n# From names (creates ID mapping)\nactors = ActorSet([\"Alice\", \"Bob\", \"Carol\", \"David\"])\n\n# Access mappings\nactors.name_to_id[\"Alice\"]  # 1\nactors.id_to_name[1]        # \"Alice\"\nactors.ids                   # [1, 2, 3, 4]\n\n# Check membership\n2 in actors   # true\n10 in actors  # false","category":"section"},{"location":"guide/events/#Risk-Sets","page":"Events and Data","title":"Risk Sets","text":"Risk sets define which dyads could potentially experience an event. This is used internally for case-control sampling.\n\nrs = RiskSet(\n    5,                        # Index of focal event\n    [1, 2, 3],                # Potential senders\n    [1, 2, 3, 4];             # Potential receivers\n    exclude_self_loops = true # Exclude s == r (default: true)\n)\n\n# Number of dyads in risk set\nn_dyads(rs)  # 3*4 - 3 = 9 (excluding self-loops)","category":"section"},{"location":"guide/events/#Working-with-Different-Time-Scales","page":"Events and Data","title":"Working with Different Time Scales","text":"","category":"section"},{"location":"guide/events/#Numeric-Time","page":"Events and Data","title":"Numeric Time","text":"For abstract time units:\n\nevents = [\n    Event(1, 2, 0.0),\n    Event(2, 1, 1.0),\n    Event(1, 2, 2.5),\n]\nseq = EventSequence(events)\n\n# Decay with numeric halflife\ndecay = halflife_to_decay(10.0)  # Half weight after 10 time units","category":"section"},{"location":"guide/events/#DateTime","page":"Events and Data","title":"DateTime","text":"For real calendar time:\n\nusing Dates\n\nevents = [\n    Event(1, 2, DateTime(2024, 1, 1, 9, 0)),   # 9:00 AM\n    Event(2, 1, DateTime(2024, 1, 1, 10, 30)), # 10:30 AM\n    Event(1, 3, DateTime(2024, 1, 1, 14, 0)),  # 2:00 PM\n]\nseq = EventSequence(events)\n\n# Decay: halflife of 1 hour = 3600 seconds\ndecay = halflife_to_decay(3600.0)\nstate = NetworkState(seq; decay=decay)","category":"section"},{"location":"guide/events/#Date","page":"Events and Data","title":"Date","text":"For daily granularity:\n\nusing Dates\n\nevents = [\n    Event(1, 2, Date(2024, 1, 1)),\n    Event(2, 1, Date(2024, 1, 8)),   # One week later\n    Event(1, 3, Date(2024, 1, 15)),  # Two weeks later\n]\nseq = EventSequence(events)\n\n# Decay: halflife of 7 days = 7 * 86400 seconds\ndecay = halflife_to_decay(7.0 * 86400)","category":"section"},{"location":"guide/events/#Data-Validation","page":"Events and Data","title":"Data Validation","text":"","category":"section"},{"location":"guide/events/#Self-Loops","page":"Events and Data","title":"Self-Loops","text":"Events where sender equals receiver generate a warning:\n\ne = Event(1, 1, 1.0)  # Warning: Self-loop detected\n\nTo filter self-loops:\n\nevents = [e for e in raw_events if e.sender != e.receiver]\nseq = EventSequence(events)","category":"section"},{"location":"guide/events/#Missing-Data","page":"Events and Data","title":"Missing Data","text":"For DataFrames with missing values:\n\n# Filter rows with missing values before loading\ndf_clean = dropmissing(df, [:sender, :receiver, :time])\nseq = load_events(df_clean)","category":"section"},{"location":"guide/events/#Duplicate-Events","page":"Events and Data","title":"Duplicate Events","text":"Events at the exact same time between the same actors are allowed but may affect some statistics:\n\nevents = [\n    Event(1, 2, 1.0),\n    Event(1, 2, 1.0),  # Duplicate - both are included\n]\nseq = EventSequence(events)\nlength(seq)  # 2","category":"section"},{"location":"guide/events/#Utility-Functions","page":"Events and Data","title":"Utility Functions","text":"","category":"section"},{"location":"guide/events/#Time-Conversions","page":"Events and Data","title":"Time Conversions","text":"# Convert halflife to decay rate\ndecay = halflife_to_decay(10.0)  # λ such that weight = 0.5 at t = 10\n\n# Convert back\nhalflife = decay_to_halflife(decay)\n\n# Compute decay weight for elapsed time\nweight = compute_decay_weight(decay, elapsed_time)","category":"section"},{"location":"guide/events/#Sequence-Statistics","page":"Events and Data","title":"Sequence Statistics","text":"# Time span\nfirst_time = seq[1].time\nlast_time = seq[end].time\nduration = last_time - first_time\n\n# Event counts by actor\nusing StatsBase\nsenders = [e.sender for e in seq]\nsender_counts = countmap(senders)\n\n# Unique dyads\ndyads = Set((e.sender, e.receiver) for e in seq)\nn_unique_dyads = length(dyads)","category":"section"},{"location":"guide/statistics/#Statistics","page":"Statistics","title":"Statistics","text":"Statistics in REM.jl capture different mechanisms that may drive event occurrence. All statistics implement a common interface and can be freely combined in models.","category":"section"},{"location":"guide/statistics/#Statistics-Interface","page":"Statistics","title":"Statistics Interface","text":"All statistics implement two methods:\n\ncompute(stat, state, sender, receiver) -> Float64\nname(stat) -> String\n\nThe compute function calculates the statistic value for a potential event from sender to receiver, given the current NetworkState.","category":"section"},{"location":"guide/statistics/#Statistic-Categories","page":"Statistics","title":"Statistic Categories","text":"REM.jl organizes statistics into five categories:\n\nType Description Examples\nDyadStatistic History between sender and receiver Repetition, Reciprocity\nDegreeStatistic Actor activity and popularity SenderActivity, ReceiverPopularity\nTriangleStatistic Triadic closure effects TransitiveClosure, CyclicClosure\nFourCycleStatistic Four-cycle clustering effects FourCycle\nNodeStatistic Node attribute effects NodeMatch, NodeDifference","category":"section"},{"location":"guide/statistics/#Dyad-Statistics","page":"Statistics","title":"Dyad Statistics","text":"These capture the history of events between the focal sender-receiver pair.","category":"section"},{"location":"guide/statistics/#Repetition","page":"Statistics","title":"Repetition","text":"Tendency to repeat past interactions:\n\n# Count of past s→r events (directed)\nRepetition()\n\n# Count of s↔r events in either direction (undirected)\nRepetition(directed=false)\n\nInterpretation: A positive coefficient indicates actors tend to interact repeatedly with the same partners.","category":"section"},{"location":"guide/statistics/#Reciprocity","page":"Statistics","title":"Reciprocity","text":"Tendency to reciprocate interactions:\n\n# Count of past r→s events\nReciprocity()\n\nInterpretation: A positive coefficient indicates actors tend to respond to those who contacted them.","category":"section"},{"location":"guide/statistics/#Inertia","page":"Statistics","title":"Inertia","text":"Combined repetition and reciprocity:\n\n# Default: equal weights\nInertiaStatistic()\n\n# Custom weights\nInertiaStatistic(repetition_weight=2.0, reciprocity_weight=1.0)\n\nFormula: inertia = rep_weight × repetition + recip_weight × reciprocity","category":"section"},{"location":"guide/statistics/#Recency","page":"Statistics","title":"Recency","text":"How recently the last event occurred on the dyad:\n\n# Inverse of elapsed time since last s→r event\nRecencyStatistic()\n\n# With different transforms\nRecencyStatistic(transform=:inverse)    # 1/elapsed (default)\nRecencyStatistic(transform=:log)        # 1/log(1+elapsed)\nRecencyStatistic(transform=:exp_decay, decay=0.1)  # exp(-0.1*elapsed)\n\nInterpretation: Captures whether recent contact increases likelihood of future contact, beyond the cumulative count.","category":"section"},{"location":"guide/statistics/#Dyad-Covariate","page":"Statistics","title":"Dyad Covariate","text":"Pre-specified dyad-level covariate:\n\n# Geographic distance between actors\ndistances = Dict(\n    (1,2) => 10.0,\n    (1,3) => 20.0,\n    (2,3) => 15.0\n)\nDyadCovariate(distances; default=100.0, name=\"distance\")\n\nUse case: Include exogenous dyad-level variables like geographic distance, organizational distance, or prior relationship strength.","category":"section"},{"location":"guide/statistics/#Degree-Statistics","page":"Statistics","title":"Degree Statistics","text":"These capture actor activity (out-degree) and popularity (in-degree).","category":"section"},{"location":"guide/statistics/#Activity-(Out-degree)","page":"Statistics","title":"Activity (Out-degree)","text":"SenderActivity()     # Sender's past sending activity\nReceiverActivity()   # Receiver's past sending activity\n\nInterpretation:\n\nSenderActivity > 0: Active senders are more likely to send (Matthew effect)\nReceiverActivity > 0: Active people are more likely to be contacted","category":"section"},{"location":"guide/statistics/#Popularity-(In-degree)","page":"Statistics","title":"Popularity (In-degree)","text":"SenderPopularity()   # Sender's past receiving (popularity)\nReceiverPopularity() # Receiver's past receiving (popularity)\n\nInterpretation:\n\nReceiverPopularity > 0: Popular actors continue to attract interactions\nSenderPopularity > 0: Popular actors are more likely to initiate contact","category":"section"},{"location":"guide/statistics/#Total-Degree","page":"Statistics","title":"Total Degree","text":"TotalDegree(role=:sender)    # Sender's in + out degree\nTotalDegree(role=:receiver)  # Receiver's in + out degree","category":"section"},{"location":"guide/statistics/#Degree-Difference","page":"Statistics","title":"Degree Difference","text":"DegreeDifference()                        # Sender out-degree - Receiver out-degree\nDegreeDifference(degree_type=:in)         # In-degree difference\nDegreeDifference(degree_type=:total)      # Total degree difference\nDegreeDifference(absolute=true)           # |difference|\n\nInterpretation: Tests whether events flow from high-degree to low-degree actors (or vice versa).","category":"section"},{"location":"guide/statistics/#Log-Degree","page":"Statistics","title":"Log Degree","text":"For networks where degree effects may be non-linear:\n\nLogDegree(role=:sender, degree_type=:out)   # log(1 + sender out-degree)\nLogDegree(role=:receiver, degree_type=:in)  # log(1 + receiver in-degree)\n\nUse case: Prevents very high-degree nodes from dominating the model.","category":"section"},{"location":"guide/statistics/#Triangle-Statistics","page":"Statistics","title":"Triangle Statistics","text":"These capture triadic closure - the tendency for events to \"close\" triangles in the network.","category":"section"},{"location":"guide/statistics/#Transitive-Closure","page":"Statistics","title":"Transitive Closure","text":"Events that close a two-path s→k→r:\n\n# Count of k where s→k and k→r\nTransitiveClosure()\n\n# Weighted by minimum edge weight\nTransitiveClosure(weighted=true)\n\nVisual representation:\n\n  k\n ↗ ↘\ns → r  ← new event closes the triangle\n\nInterpretation: \"Friends of friends become friends\" - actors are more likely to interact if they share common contacts.","category":"section"},{"location":"guide/statistics/#Cyclic-Closure","page":"Statistics","title":"Cyclic Closure","text":"Events that form a cycle r→k→s:\n\n# Count of k where r→k and k→s\nCyclicClosure()\n\nVisual representation:\n\n  k\n ↗ ↙\nr ← s  ← new s→r event closes the cycle\n\nInterpretation: Tendency to complete directed cycles (common in reciprocal exchange networks).","category":"section"},{"location":"guide/statistics/#Shared-Sender","page":"Statistics","title":"Shared Sender","text":"Common sender k who sent to both s and r:\n\n# Count of k where k→s and k→r\nSharedSender()\n\nInterpretation: Actors contacted by the same third party are more likely to interact.","category":"section"},{"location":"guide/statistics/#Shared-Receiver","page":"Statistics","title":"Shared Receiver","text":"Common receiver k who received from both s and r:\n\n# Count of k where s→k and r→k\nSharedReceiver()\n\nInterpretation: Actors who contacted the same third party are more likely to interact.","category":"section"},{"location":"guide/statistics/#Common-Neighbors-(Undirected)","page":"Statistics","title":"Common Neighbors (Undirected)","text":"# Any common neighbor regardless of direction\nCommonNeighbors()","category":"section"},{"location":"guide/statistics/#Geometrically-Weighted-Triads","page":"Statistics","title":"Geometrically Weighted Triads","text":"Down-weights additional shared partners (similar to GWESP in ERGM):\n\nGeometricWeightedTriads(closure_type=:transitive, alpha=0.5)\nGeometricWeightedTriads(closure_type=:cyclic, alpha=0.5)\nGeometricWeightedTriads(closure_type=:shared_sender, alpha=0.5)\nGeometricWeightedTriads(closure_type=:shared_receiver, alpha=0.5)\n\nParameter α: Controls how quickly additional shared partners are down-weighted. Lower α = stronger down-weighting.","category":"section"},{"location":"guide/statistics/#Four-Cycle-Statistics","page":"Statistics","title":"Four-Cycle Statistics","text":"These capture clustering through pairs of intermediaries, forming four-node structures.","category":"section"},{"location":"guide/statistics/#Four-Cycle","page":"Statistics","title":"Four-Cycle","text":"Various four-cycle configurations:\n\n# Different cycle types\nFourCycle(cycle_type=:out_out)  # s→j←k→r (shared out-neighbor pattern)\nFourCycle(cycle_type=:in_in)    # s←j→k←r (shared in-neighbor pattern)\nFourCycle(cycle_type=:out_in)   # s→j→k→r (chain pattern)\nFourCycle(cycle_type=:in_out)   # s←j←k←r (reverse chain)\nFourCycle(cycle_type=:mixed)    # All patterns combined\n\nVisual representation (out_out):\n\ns → j\n    ↑\n    k → r\n\nInterpretation: Captures higher-order clustering beyond triangles.","category":"section"},{"location":"guide/statistics/#Geometrically-Weighted-Four-Cycles","page":"Statistics","title":"Geometrically Weighted Four-Cycles","text":"GeometricWeightedFourCycles(cycle_type=:out_out, alpha=0.5)","category":"section"},{"location":"guide/statistics/#Node-Attribute-Statistics","page":"Statistics","title":"Node Attribute Statistics","text":"These incorporate actor-level attributes for homophily and covariate effects.","category":"section"},{"location":"guide/statistics/#Homophily-(Node-Match)","page":"Statistics","title":"Homophily (Node Match)","text":"Indicator for matching attributes:\n\ngender = NodeAttribute(:gender, Dict(1=>\"M\", 2=>\"F\", 3=>\"M\"), \"Unknown\")\n\n# Returns 1.0 if sender and receiver have same gender, 0.0 otherwise\nNodeMatch(gender)\n\nInterpretation: Positive coefficient = homophily (like attracts like).","category":"section"},{"location":"guide/statistics/#Mixing-Patterns-(Node-Mix)","page":"Statistics","title":"Mixing Patterns (Node Mix)","text":"Indicator for specific sender-receiver attribute combinations:\n\n# Returns 1.0 if sender is \"M\" and receiver is \"F\"\nNodeMix(gender, \"M\", \"F\")\n\nUse case: Test for asymmetric patterns (e.g., do men contact women more than vice versa?).","category":"section"},{"location":"guide/statistics/#Attribute-Difference","page":"Statistics","title":"Attribute Difference","text":"For numeric attributes:\n\nage = NodeAttribute(:age, Dict(1=>25.0, 2=>30.0), 0.0)\n\n# sender_age - receiver_age\nNodeDifference(age)\n\n# |sender_age - receiver_age|\nNodeDifference(age; absolute=true)\n\nInterpretation:\n\nNodeDifference < 0: Events flow from younger to older (or similar attribute direction)\nNodeDifference(absolute=true) < 0: Events are more likely between similar actors","category":"section"},{"location":"guide/statistics/#Attribute-Sum-and-Product","page":"Statistics","title":"Attribute Sum and Product","text":"NodeSum(age)      # sender_age + receiver_age\nNodeProduct(age)  # sender_age * receiver_age","category":"section"},{"location":"guide/statistics/#Main-Effects","page":"Statistics","title":"Main Effects","text":"Include attribute as a main effect on sender or receiver:\n\n# Numeric attributes\nSenderAttribute(age)    # Sender's age affects rate\nReceiverAttribute(age)  # Receiver's age affects rate\n\n# Categorical attributes (indicator for specific value)\nSenderCategorical(gender, \"M\")    # 1.0 if sender is \"M\"\nReceiverCategorical(gender, \"F\")  # 1.0 if receiver is \"F\"","category":"section"},{"location":"guide/statistics/#Using-Statistics-in-Practice","page":"Statistics","title":"Using Statistics in Practice","text":"","category":"section"},{"location":"guide/statistics/#Building-a-Model","page":"Statistics","title":"Building a Model","text":"# Create node attributes\ngender = NodeAttribute(:gender, Dict(1=>\"M\", 2=>\"F\", 3=>\"M\"), \"Unknown\")\ntenure = NodeAttribute(:tenure, Dict(1=>5.0, 2=>10.0, 3=>3.0), 0.0)\n\n# Build comprehensive model\nstats = [\n    # Dyadic effects\n    Repetition(),\n    Reciprocity(),\n\n    # Degree effects\n    SenderActivity(),\n    ReceiverPopularity(),\n\n    # Structural effects\n    TransitiveClosure(),\n    CyclicClosure(),\n\n    # Attribute effects\n    NodeMatch(gender),\n    NodeDifference(tenure; absolute=true),\n]","category":"section"},{"location":"guide/statistics/#Computing-Statistics-Manually","page":"Statistics","title":"Computing Statistics Manually","text":"# Create network state\nstate = NetworkState(seq)\n\n# Process some events to build history\nfor i in 1:5\n    update!(state, seq[i])\nend\n\n# Compute a single statistic for a potential event\nrep = Repetition()\nvalue = compute(rep, state, sender_id, receiver_id)\n\n# Compute all statistics\nvalues = compute_all(stats, state, sender_id, receiver_id)","category":"section"},{"location":"guide/statistics/#Custom-Statistic-Names","page":"Statistics","title":"Custom Statistic Names","text":"All statistics accept a name parameter for custom naming:\n\nRepetition(name=\"past_interactions\")\nTransitiveClosure(name=\"friends_of_friends\")\nNodeMatch(gender; name=\"same_gender\")\n\nThis is useful when fitting multiple versions of the same statistic:\n\nstats = [\n    Repetition(directed=true, name=\"repetition_directed\"),\n    Repetition(directed=false, name=\"repetition_undirected\"),\n]","category":"section"},{"location":"guide/statistics/#Statistic-Sets","page":"Statistics","title":"Statistic Sets","text":"For convenient handling of multiple statistics:\n\nss = StatisticSet([\n    Repetition(),\n    Reciprocity(),\n    TransitiveClosure(),\n])\n\n# Access\nlength(ss)     # 3\nss[1]          # Repetition()\nss.names       # [\"repetition\", \"reciprocity\", \"transitive_closure\"]\n\n# Compute all\nvalues = compute_all(ss, state, sender, receiver)","category":"section"},{"location":"guide/statistics/#Choosing-Statistics","page":"Statistics","title":"Choosing Statistics","text":"","category":"section"},{"location":"guide/statistics/#By-Research-Question","page":"Statistics","title":"By Research Question","text":"Question Statistics\nDo past interactions predict future ones? Repetition, Reciprocity\nIs there preferential attachment? SenderActivity, ReceiverPopularity\nDoes the network cluster? TransitiveClosure, CyclicClosure, FourCycle\nIs there homophily? NodeMatch, NodeDifference\nDo attributes affect sending/receiving? SenderAttribute, ReceiverAttribute","category":"section"},{"location":"guide/statistics/#Best-Practices","page":"Statistics","title":"Best Practices","text":"Start with dyadic effects: Repetition and Reciprocity are almost always relevant\nAdd degree effects: Control for baseline activity/popularity differences\nTest structural effects carefully: Triadic statistics can be correlated with degree\nInclude relevant attributes: Based on domain knowledge\nAvoid multicollinearity: Don't include highly correlated statistics\nUse log transforms for degree: Especially in networks with high-degree hubs","category":"section"},{"location":"api/statistics/#Statistics-API-Reference","page":"Statistics","title":"Statistics API Reference","text":"This page documents all statistics available in REM.jl.","category":"section"},{"location":"api/statistics/#Base-Types-and-Interface","page":"Statistics","title":"Base Types and Interface","text":"","category":"section"},{"location":"api/statistics/#Abstract-Types","page":"Statistics","title":"Abstract Types","text":"","category":"section"},{"location":"api/statistics/#Interface-Functions","page":"Statistics","title":"Interface Functions","text":"","category":"section"},{"location":"api/statistics/#StatisticSet","page":"Statistics","title":"StatisticSet","text":"","category":"section"},{"location":"api/statistics/#Dyad-Statistics","page":"Statistics","title":"Dyad Statistics","text":"Statistics based on the history of events between the focal sender-receiver pair.","category":"section"},{"location":"api/statistics/#Degree-Statistics","page":"Statistics","title":"Degree Statistics","text":"Statistics based on actor activity (out-degree) and popularity (in-degree).","category":"section"},{"location":"api/statistics/#Triangle-Statistics","page":"Statistics","title":"Triangle Statistics","text":"Statistics capturing triadic closure effects in directed networks.","category":"section"},{"location":"api/statistics/#Four-Cycle-Statistics","page":"Statistics","title":"Four-Cycle Statistics","text":"Statistics capturing higher-order clustering through four-node structures.","category":"section"},{"location":"api/statistics/#Node-Attribute-Statistics","page":"Statistics","title":"Node Attribute Statistics","text":"Statistics incorporating actor-level attributes for homophily and covariate effects.","category":"section"},{"location":"api/statistics/#REM.AbstractStatistic","page":"Statistics","title":"REM.AbstractStatistic","text":"AbstractStatistic\n\nAbstract base type for all REM statistics.\n\nAll statistics must implement:\n\ncompute(stat::AbstractStatistic, state::NetworkState, sender::Int, receiver::Int) -> Float64\nname(stat::AbstractStatistic) -> String\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.DyadStatistic","page":"Statistics","title":"REM.DyadStatistic","text":"DyadStatistic <: AbstractStatistic\n\nStatistics that depend on the history of events between the focal dyad (sender, receiver). Examples: repetition, reciprocity, inertia.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.DegreeStatistic","page":"Statistics","title":"REM.DegreeStatistic","text":"DegreeStatistic <: AbstractStatistic\n\nStatistics that depend on the degree (activity/popularity) of actors. Examples: sender activity, receiver popularity.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.TriangleStatistic","page":"Statistics","title":"REM.TriangleStatistic","text":"TriangleStatistic <: AbstractStatistic\n\nStatistics that measure triadic closure effects. Examples: transitive closure, cyclic closure, shared partners.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.FourCycleStatistic","page":"Statistics","title":"REM.FourCycleStatistic","text":"FourCycleStatistic <: AbstractStatistic\n\nStatistics that measure four-cycle (local clustering) effects.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.NodeStatistic","page":"Statistics","title":"REM.NodeStatistic","text":"NodeStatistic <: AbstractStatistic\n\nStatistics based on node-level attributes. Examples: homophily, attribute matching.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.InteractionStatistic","page":"Statistics","title":"REM.InteractionStatistic","text":"InteractionStatistic <: AbstractStatistic\n\nStatistics that capture interaction effects between attributes.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.compute","page":"Statistics","title":"REM.compute","text":"compute(stat::AbstractStatistic, state::NetworkState, sender::Int, receiver::Int) -> Float64\n\nCompute the statistic value for a potential event from sender to receiver. This is the main interface that all statistics must implement.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#REM.name","page":"Statistics","title":"REM.name","text":"name(stat::AbstractStatistic) -> String\n\nReturn a descriptive name for the statistic.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#REM.StatisticSet","page":"Statistics","title":"REM.StatisticSet","text":"StatisticSet\n\nA collection of statistics to compute together.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.compute_all","page":"Statistics","title":"REM.compute_all","text":"compute_all(ss::StatisticSet, state::NetworkState, sender::Int, receiver::Int) -> Vector{Float64}\n\nCompute all statistics in the set for a potential event.\n\n\n\n\n\ncompute_all(stats::Vector{<:AbstractStatistic}, state::NetworkState, sender::Int, receiver::Int) -> Vector{Float64}\n\nCompute all statistics for a potential event.\n\n\n\n\n\n","category":"function"},{"location":"api/statistics/#REM.Repetition","page":"Statistics","title":"REM.Repetition","text":"Repetition <: DyadStatistic\n\nMeasures the tendency for repeated events from sender to receiver. Returns the (weighted) count of past events from sender to receiver.\n\nFields\n\ndirected::Bool: If true, count only events from s→r. If false, count events in both directions.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.Reciprocity","page":"Statistics","title":"REM.Reciprocity","text":"Reciprocity <: DyadStatistic\n\nMeasures the tendency for reciprocal events. Returns the (weighted) count of past events from receiver to sender.\n\nFields\n\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.InertiaStatistic","page":"Statistics","title":"REM.InertiaStatistic","text":"InertiaStatistic <: DyadStatistic\n\nMeasures inertia - the tendency for events to persist in a direction. Combines repetition and reciprocity effects.\n\nReturns: repetitionweight * repetition + reciprocityweight * reciprocity\n\nFields\n\nrepetition_weight::Float64: Weight for repetition component.\nreciprocity_weight::Float64: Weight for reciprocity component.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.RecencyStatistic","page":"Statistics","title":"REM.RecencyStatistic","text":"RecencyStatistic <: DyadStatistic\n\nMeasures recency - how recently the last event occurred on this dyad. Returns the inverse of elapsed time since last event (or 0 if no prior events).\n\nFields\n\ndirected::Bool: If true, only consider events from s→r.\ntransform::Symbol: Transform to apply (:inverse, :log, :exp_decay).\ndecay::Float64: Decay parameter for :exp_decay transform.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.DyadCovariate","page":"Statistics","title":"REM.DyadCovariate","text":"DyadCovariate <: DyadStatistic\n\nA statistic based on a pre-specified dyad-level covariate matrix.\n\nFields\n\nvalues::Dict{Tuple{Int,Int}, Float64}: Mapping from dyad to covariate value.\ndefault::Float64: Default value for dyads not in the dict.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.SenderActivity","page":"Statistics","title":"REM.SenderActivity","text":"SenderActivity <: DegreeStatistic\n\nMeasures the sender's past activity (out-degree). Returns the (weighted) number of past events sent by the sender.\n\nFields\n\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.ReceiverActivity","page":"Statistics","title":"REM.ReceiverActivity","text":"ReceiverActivity <: DegreeStatistic\n\nMeasures the receiver's past activity (out-degree). Returns the (weighted) number of past events sent by the receiver.\n\nFields\n\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.SenderPopularity","page":"Statistics","title":"REM.SenderPopularity","text":"SenderPopularity <: DegreeStatistic\n\nMeasures the sender's past popularity (in-degree). Returns the (weighted) number of past events received by the sender.\n\nFields\n\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.ReceiverPopularity","page":"Statistics","title":"REM.ReceiverPopularity","text":"ReceiverPopularity <: DegreeStatistic\n\nMeasures the receiver's past popularity (in-degree). Returns the (weighted) number of past events received by the receiver.\n\nFields\n\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.TotalDegree","page":"Statistics","title":"REM.TotalDegree","text":"TotalDegree <: DegreeStatistic\n\nMeasures the total degree (in + out) of an actor.\n\nFields\n\nrole::Symbol: Which actor's degree to compute (:sender or :receiver).\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.DegreeDifference","page":"Statistics","title":"REM.DegreeDifference","text":"DegreeDifference <: DegreeStatistic\n\nMeasures the difference in degree between sender and receiver.\n\nFields\n\ndegree_type::Symbol: Type of degree to compare (:out, :in, or :total).\nabsolute::Bool: If true, return absolute difference.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.LogDegree","page":"Statistics","title":"REM.LogDegree","text":"LogDegree <: DegreeStatistic\n\nMeasures the log-transformed degree of an actor. Uses log(1 + degree) to handle zero degrees.\n\nFields\n\nrole::Symbol: Which actor's degree to compute (:sender or :receiver).\ndegree_type::Symbol: Type of degree (:out, :in, or :total).\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.TransitiveClosure","page":"Statistics","title":"REM.TransitiveClosure","text":"TransitiveClosure <: TriangleStatistic\n\nMeasures transitive closure: tendency for s→r when there exists k such that s→k→r. Returns the count of actors k who have received from s and sent to r.\n\nFields\n\nweighted::Bool: If true, weight by edge weights.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.CyclicClosure","page":"Statistics","title":"REM.CyclicClosure","text":"CyclicClosure <: TriangleStatistic\n\nMeasures cyclic closure: tendency for s→r when there exists k such that r→k→s. Returns the count of actors k who have received from r and sent to s.\n\nFields\n\nweighted::Bool: If true, weight by edge weights.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.SharedSender","page":"Statistics","title":"REM.SharedSender","text":"SharedSender <: TriangleStatistic\n\nMeasures shared sender effect: tendency for s→r when there exists k such that k→s and k→r. Returns the count of actors k who have sent to both s and r.\n\nFields\n\nweighted::Bool: If true, weight by edge weights.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.SharedReceiver","page":"Statistics","title":"REM.SharedReceiver","text":"SharedReceiver <: TriangleStatistic\n\nMeasures shared receiver effect: tendency for s→r when there exists k such that s→k and r→k. Returns the count of actors k who have received from both s and r.\n\nFields\n\nweighted::Bool: If true, weight by edge weights.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.CommonNeighbors","page":"Statistics","title":"REM.CommonNeighbors","text":"CommonNeighbors <: TriangleStatistic\n\nMeasures the number of common neighbors (undirected) between sender and receiver.\n\nFields\n\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.GeometricWeightedTriads","page":"Statistics","title":"REM.GeometricWeightedTriads","text":"GeometricWeightedTriads <: TriangleStatistic\n\nGeometrically weighted shared partner statistic. Down-weights the contribution of additional shared partners.\n\nFields\n\nclosure_type::Symbol: Type of closure (:transitive, :cyclic, :sharedsender, :sharedreceiver).\nalpha::Float64: Decay parameter (higher = less down-weighting).\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.FourCycle","page":"Statistics","title":"REM.FourCycle","text":"FourCycle <: FourCycleStatistic\n\nMeasures four-cycle closure: tendency for s→r when there exist j, k such that s→j, k→j, and k→r (or variants).\n\nThis captures local clustering where sender and receiver share connections to a common pair of intermediaries.\n\nFields\n\ncycle_type::Symbol: Type of four-cycle configuration.\n:out_out: s→j←k→r (shared out-neighbor pattern)\n:in_in: s←j→k←r (shared in-neighbor pattern)\n:out_in: s→j→k→r (two-path through intermediaries)\n:mixed: any configuration\nweighted::Bool: If true, weight by edge weights.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.GeometricWeightedFourCycles","page":"Statistics","title":"REM.GeometricWeightedFourCycles","text":"GeometricWeightedFourCycles <: FourCycleStatistic\n\nGeometrically weighted four-cycle statistic. Down-weights the contribution of additional four-cycles.\n\nFields\n\ncycle_type::Symbol: Type of four-cycle configuration.\nalpha::Float64: Decay parameter (higher = less down-weighting).\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.NodeMatch","page":"Statistics","title":"REM.NodeMatch","text":"NodeMatch <: NodeStatistic\n\nMeasures homophily: tendency for events between actors with matching attributes. Returns 1.0 if sender and receiver have the same attribute value, 0.0 otherwise.\n\nFields\n\nattribute::NodeAttribute: The attribute to match on.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.NodeMix","page":"Statistics","title":"REM.NodeMix","text":"NodeMix <: NodeStatistic\n\nMeasures mixing patterns: indicator for specific sender-receiver attribute combinations. Returns 1.0 if sender has value sender_value and receiver has receiver_value.\n\nFields\n\nattribute::NodeAttribute: The attribute to check.\nsender_value: Required sender attribute value.\nreceiver_value: Required receiver attribute value.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.NodeDifference","page":"Statistics","title":"REM.NodeDifference","text":"NodeDifference <: NodeStatistic\n\nMeasures the difference in a numeric attribute between sender and receiver.\n\nFields\n\nattribute::NodeAttribute{<:Number}: The numeric attribute.\nabsolute::Bool: If true, return absolute difference.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.NodeSum","page":"Statistics","title":"REM.NodeSum","text":"NodeSum <: NodeStatistic\n\nMeasures the sum of a numeric attribute for sender and receiver.\n\nFields\n\nattribute::NodeAttribute{<:Number}: The numeric attribute.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.NodeProduct","page":"Statistics","title":"REM.NodeProduct","text":"NodeProduct <: NodeStatistic\n\nMeasures the product of a numeric attribute for sender and receiver.\n\nFields\n\nattribute::NodeAttribute{<:Number}: The numeric attribute.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.SenderAttribute","page":"Statistics","title":"REM.SenderAttribute","text":"SenderAttribute <: NodeStatistic\n\nReturns the sender's attribute value (as a main effect).\n\nFields\n\nattribute::NodeAttribute{<:Number}: The numeric attribute.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.ReceiverAttribute","page":"Statistics","title":"REM.ReceiverAttribute","text":"ReceiverAttribute <: NodeStatistic\n\nReturns the receiver's attribute value (as a main effect).\n\nFields\n\nattribute::NodeAttribute{<:Number}: The numeric attribute.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.SenderCategorical","page":"Statistics","title":"REM.SenderCategorical","text":"SenderCategorical <: NodeStatistic\n\nReturns 1.0 if sender has a specific categorical attribute value.\n\nFields\n\nattribute::NodeAttribute: The categorical attribute.\nvalue: The value to match.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"api/statistics/#REM.ReceiverCategorical","page":"Statistics","title":"REM.ReceiverCategorical","text":"ReceiverCategorical <: NodeStatistic\n\nReturns 1.0 if receiver has a specific categorical attribute value.\n\nFields\n\nattribute::NodeAttribute: The categorical attribute.\nvalue: The value to match.\nstat_name::String: Name for this statistic.\n\n\n\n\n\n","category":"type"},{"location":"#REM.jl","page":"Home","title":"REM.jl","text":"Relational Event Models for Julia\n\nA Julia package for statistical analysis of time-stamped relational events in networks.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"Relational Event Models (REM) are statistical models for analyzing sequences of time-stamped relational events. An event is a directed interaction from a sender to a receiver at a specific point in time. REMs uncover factors explaining why certain actors interact at higher rates than others.\n\nREM.jl is a port of eventnet, providing efficient tools for modeling sequences of directed interactions between actors.","category":"section"},{"location":"#What-is-a-Relational-Event?","page":"Home","title":"What is a Relational Event?","text":"A relational event is a time-stamped directed interaction:\n\nActor A → Actor B at time t\n\nExamples include:\n\nEmails sent between colleagues\nMessages in a chat application\nTrade transactions between countries\nCollaboration events between scientists","category":"section"},{"location":"#Key-Concepts","page":"Home","title":"Key Concepts","text":"Concept Description\nRelational Event A time-stamped directed interaction (sender → receiver)\nEvent Sequence A chronologically ordered sequence of relational events\nNetwork State The cumulative state of interactions up to a point in time\nStatistic A computed feature that may predict event occurrence\nHazard Rate The instantaneous probability of an event occurring","category":"section"},{"location":"#Applications","page":"Home","title":"Applications","text":"REMs are widely used in:\n\nSocial network analysis: Understanding communication patterns\nOrganizational studies: Modeling collaboration and coordination\nInternational relations: Analyzing diplomatic interactions\nAnimal behavior: Studying social hierarchies and mating patterns\nOnline platforms: Modeling user interactions and content sharing","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Rich statistic library: 25+ statistics covering dyadic, degree, triadic, four-cycle, and attribute effects\nEfficient computation: Incremental network state updates for fast statistic calculation\nTemporal decay: Support for exponential decay of network effects\nCase-control sampling: Efficient estimation for large networks via stratified conditional logistic regression\nFlexible timestamps: Works with numeric, DateTime, and Date timestamps\nEasy data loading: Load events from DataFrames or CSV files","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/simoneSantoni/REM.jl\")\n\nOr for development:\n\nusing Pkg\nPkg.develop(path=\"/path/to/REM.jl\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using REM\n\n# Create events\nevents = [\n    Event(1, 2, 1.0),  # Actor 1 → Actor 2 at time 1.0\n    Event(2, 1, 2.0),  # Actor 2 → Actor 1 at time 2.0 (reciprocation)\n    Event(1, 3, 3.0),  # Actor 1 → Actor 3 at time 3.0\n    Event(1, 2, 4.0),  # Actor 1 → Actor 2 at time 4.0 (repetition)\n]\nseq = EventSequence(events)\n\n# Define model statistics\nstats = [\n    Repetition(),        # Tendency to repeat past interactions\n    Reciprocity(),       # Tendency to reciprocate\n    SenderActivity(),    # Sender's past activity level\n    ReceiverPopularity() # Receiver's past popularity\n]\n\n# Fit model with case-control sampling\nresult = fit_rem(seq, stats; n_controls=100, seed=42)\n\n# View results\nprintln(result)","category":"section"},{"location":"#Choosing-Statistics","page":"Home","title":"Choosing Statistics","text":"Use Case Recommended Statistics\nBasic dyadic effects Repetition, Reciprocity\nActor heterogeneity SenderActivity, ReceiverPopularity\nTriadic closure TransitiveClosure, CyclicClosure\nHomophily effects NodeMatch, NodeDifference\nTime-varying effects RecencyStatistic + temporal decay\nComplex clustering FourCycle, GeometricWeightedTriads","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"Pages = [\n    \"getting_started.md\",\n    \"guide/events.md\",\n    \"guide/statistics.md\",\n    \"guide/estimation.md\",\n    \"guide/decay.md\",\n    \"api/types.md\",\n    \"api/statistics.md\",\n    \"api/estimation.md\",\n]\nDepth = 2","category":"section"},{"location":"#Theoretical-Background","page":"Home","title":"Theoretical Background","text":"","category":"section"},{"location":"#The-Relational-Event-Model","page":"Home","title":"The Relational Event Model","text":"REMs model the rate at which events occur as a function of the network's history. For a potential event from sender s to receiver r at time t, the hazard rate is:\n\nlambda_sr(t) = expleft(sum_k beta_k x_k(s r t)right)\n\nWhere:\n\nx_k(s r t)\nare statistics computed from the network history\nbeta_k\nare coefficients to be estimated","category":"section"},{"location":"#Case-Control-Sampling","page":"Home","title":"Case-Control Sampling","text":"For large networks, computing statistics for all possible dyads is expensive. REM.jl uses case-control sampling:\n\nFor each observed event (case), sample non-events (controls) from the risk set\nCompute statistics for both cases and controls\nEstimate via stratified conditional logistic regression\n\nThis approach is statistically consistent and dramatically reduces computation time.","category":"section"},{"location":"#References","page":"Home","title":"References","text":"Butts, C.T. (2008). A relational event framework for social action. Sociological Methodology, 38(1), 155-200.\nLerner, J., Lomi, A. (2020). Reliability of relational event model estimates under sampling: How to fit a relational event model to 360 million dyadic events. Network Science, 8(1), 97-135.\nLerner, J., Bussmann, M., Snijders, T.A.B., Brandes, U. (2013). Modeling frequency and type of interaction in event networks. Corvinus Journal of Sociology and Social Policy, 4(1), 3-32.\nBrandes, U., Lerner, J., Snijders, T.A.B. (2009). Networks evolving step by step: Statistical analysis of dyadic event data. 2009 International Conference on Advances in Social Network Analysis and Mining, 200-205.\nPerry, P.O., Wolfe, P.J. (2013). Point process modelling for directed interaction networks. Journal of the Royal Statistical Society: Series B, 75(5), 821-849.","category":"section"}]
}
